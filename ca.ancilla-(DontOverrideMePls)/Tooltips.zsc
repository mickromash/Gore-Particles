// Common code shared between the TooltipListMenu and TooltipOptionMenu.

class MRGP_Tooltip : Object ui {
  double x, y, w, xpad, ypad, scale; // Geometry
  double Cx, Cy, Cw, Cxpad, Cypad, Cscale;
  int first, last; // First and last menuitems this applies to
  Font font;
  Color colour;
  TextureID texture;
  string text;

  void CopyFrom(MRGP_Tooltip settings) {
    self.x = settings.x;
    self.y = settings.y;
    self.w = settings.w;
    self.xpad = settings.xpad;
    self.ypad = settings.ypad;
    self.scale = settings.scale;
	self.Cx = settings.Cx;
    self.Cy = settings.Cy;
    self.Cw = settings.Cw;
    self.Cxpad = settings.Cxpad;
    self.Cypad = settings.Cypad;
    self.Cscale = settings.Cscale;
    self.font = settings.font;
    self.colour = settings.colour;
    self.texture = settings.texture;
  }

  int GetX(uint screen_width, uint width) {
    if (width > screen_width) return 0;
    return (screen_width - width) * self.x;
  }

  int GetY(uint screen_height, uint height) {
    if (height > screen_height) return 0;
    return (screen_height - height) * self.y;
  }
  
  int GetCX(uint screen_width, uint width) {
    if (width > screen_width) return 0;
    return (screen_width - width) * self.Cx;
  }

  int GetCY(uint screen_height, uint height) {
    if (height > screen_height) return 0;
    return (screen_height - height) * self.Cy;
  }

  void Draw() {
	DrawTip();
	String Text = self.text;
	if(Text.IndexOf("_(")<0)Return;
	int Type;
	String STyp = Text.Mid(Text.IndexOf("_(")+2);
	STyp = STyp.Left(STyp.IndexOf(")")).MakeLower();
	Name Typ = STyp;
	Switch(Typ)
	{
		Case 'bool': Type = 0;Break;
		Case 'int': Type = 1;Break;
		Case 'float': Case 'double': Type = 2;Break;
		Case 'string': Type = 3;Break;
		Case 'color': Type = 4;Break;
		Case 'type': Type = 5;Break;
	}
	Text.Replace("$", "");
	Text = Text.Left(Text.IndexOf("Tip_"));
	if(CVar.FindCVar(Text))DrawCVar(Text, Type);
  }
  
  Void DrawTip() {
    // In order to draw the text readably at high resolutions, we calculate
    // everything using a virtual screen size and then tell DrawTexture and
    // DrawText to scale appropriately when blitting the background and tooltip
    // text to the real screen.
    uint virtual_height = screen.GetHeight() / CleanYFac_1 / scale;
    let aspect = screen.GetAspectRatio();
    let virtual_width = virtual_height * aspect;
    // Font metrics: em width and line height.
    let em = self.font.GetCharWidth(0x6D);
    let lh = self.font.GetHeight();
    // Nominal width is the maximum width of the tooltip based on configuration
    // in the MENUDEF.
    let nominal_width = virtual_width * self.w;
	String Text = self.text.MakeLower();
	if(Text.IndexOf("tip_(")>-1)Text = Text.Left(Text.IndexOf("_("));
	let localtooltip = Stringtable.localize(Text);
    let lines = self.font.BreakLines(localtooltip, nominal_width);

    // Calculate the real width of the tooltip. This may be less than the
    // nominal width if it's a short one-liner. This is still in virtual screen
    // coordinates, not real screen!
    uint actual_width = 0;
    for (int i = 0; i < lines.count(); ++i) {
      actual_width = max(actual_width, self.font.StringWidth(lines.StringAt(i)));
    }
    actual_width += self.xpad * 2.0 * em;

    // Calculate the real height based on the number of lines we wrapped it into
    // and the vertical margins.
    uint actual_height = self.font.GetHeight() * (self.ypad * 2.0 + lines.count());

    // Get the coordinates of the top left corner of the tooltip's bounding box,
    // including padding, in virtual screen coordinates.
    uint x = GetX(virtual_width, actual_width);
    uint y = GetY(virtual_height, actual_height);
	
    // Draw the background texture, if defined. DTA_Virtual* commands it to scale
    // the virtual screen size to match the real screen; DTA_KeepRatio tells it
    // to assume the ratio of the virtual screen matches the real screen. (The
    // documentation on the wiki is wrong here; leaving it false forces a 4:3
    // aspect ratio.)
    Screen.DrawTexture(texture, true, x, y,
        DTA_VirtualWidthF, virtual_width, DTA_VirtualHeight, virtual_height,
        DTA_KeepRatio, true,
        DTA_LeftOffset, 0, DTA_TopOffset, 0,
        DTA_DestWidth, actual_width+10, DTA_DestHeight, actual_height);

    for (int i = 0; i < lines.count(); ++i) {
      screen.DrawText(
        self.font, self.colour,
        x + 5 + self.xpad*em,
        y + i*lh + self.ypad*lh,
        lines.StringAt(i),
        DTA_VirtualWidthF, virtual_width, DTA_VirtualHeight, virtual_height,
        DTA_KeepRatio, true);
    }
  }
  
	Void DrawCVar(String CVa, int Type) {
		// In order to draw the text readably at high resolutions, we calculate
		// everything using a virtual screen size and then tell DrawTexture and
		// DrawText to scale appropriately when blitting the background and tooltip
		// text to the real screen.
		uint virtual_height = screen.GetHeight() / CleanYFac_1 / Cscale;
		let aspect = screen.GetAspectRatio();
		let virtual_width = virtual_height * aspect;
		// Font metrics: em width and line height.
		let em = self.font.GetCharWidth(0x6D);
		let lh = self.font.GetHeight();
		// Nominal width is the maximum width of the tooltip based on configuration
		// in the MENUDEF.
		let nominal_width = virtual_width * self.Cw;
		String Text;
		Text = StringTable.Localize("$MRGoreParts_Tips_CVarStart")..CVa.."\c-\n"..StringTable.Localize("$MRGoreParts_Tips_CVarEnd");
		Switch(Type)
		{
			Case 0://Bool
				Text = Text..(CVar.FindCVar(CVa).GetDefaultBool()?StringTable.Localize("$TXT_YES"):StringTable.Localize("$TXT_NO"));
				Break;
			Case 1://int
				Text = Text..CVar.FindCVar(CVa).GetDefaultInt();
				Break;
			Case 2://Double
				Text = String.Format("%s %.2f", Text, CVar.FindCVar(CVa).GetDefaultFloat());
				Break;
			Case 3://String
				Text = Text.."\""..CVar.FindCVar(CVa).GetDefaultString().."\"";
				Break;
			Case 4://Color
				Color Val = CVar.FindCVar(CVa).GetDefaultInt();
				Text = Text.."\c-(\cg"..Val.R.." \cd"..Val.G.." \cy"..Val.B.."\c-)";
				Break;
			Case 5://Type
				String Option = "$"..CVa;
				if(StringTable.Localize(Option..CVar.FindCVar(CVa).GetDefaultInt())!=Option..CVar.FindCVar(CVa).GetDefaultInt())Text = Text..StringTable.Localize(Option..CVar.FindCVar(CVa).GetDefaultInt());
				else Text = Text..CVar.FindCVar(CVa).GetDefaultInt();
				Break;
		}
		let lines = self.font.BreakLines(Text, nominal_width);

		// Calculate the real width of the tooltip. This may be less than the
		// nominal width if it's a short one-liner. This is still in virtual screen
		// coordinates, not real screen!
		uint actual_width = 0;
		for (int i = 0; i < lines.count(); ++i) {
		  actual_width = max(actual_width, self.font.StringWidth(lines.StringAt(i)));
		}
		actual_width += self.Cxpad * 2.0 * em;

		// Calculate the real height based on the number of lines we wrapped it into
		// and the vertical margins.
		uint actual_height = self.font.GetHeight() * (self.Cypad * 2.0 + lines.count());

		// Get the coordinates of the top left corner of the tooltip's bounding box,
		// including padding, in virtual screen coordinates.
		uint x = GetCX(virtual_width, actual_width);
		uint y = GetCY(virtual_height, actual_height);
		
		// Draw the background texture, if defined. DTA_Virtual* commands it to scale
		// the virtual screen size to match the real screen; DTA_KeepRatio tells it
		// to assume the ratio of the virtual screen matches the real screen. (The
		// documentation on the wiki is wrong here; leaving it false forces a 4:3
		// aspect ratio.)
		Screen.DrawTexture(texture, true, x, y,
			DTA_VirtualWidthF, virtual_width, DTA_VirtualHeight, virtual_height,
			DTA_KeepRatio, true,
			DTA_LeftOffset, 0, DTA_TopOffset, 0,
			DTA_DestWidth, actual_width+10, DTA_DestHeight, actual_height);

		for (int i = 0; i < lines.count(); ++i) {
		  screen.DrawText(
			self.font, self.colour,
			x + 5 + self.xpad*em,
			y + i*lh + self.ypad*lh,
			lines.StringAt(i),
			DTA_VirtualWidthF, virtual_width, DTA_VirtualHeight, virtual_height,
			DTA_KeepRatio, true);
		}
	}
}

// Mixin classes used for the menu and menu items.
mixin class MRGP_TooltipMenu {
  array<MRGP_Tooltip> tooltips;
  MRGP_Tooltip tooltip_settings;

  // Default settings:
  // - top left corner
  // - 30% of the screen width
  // - 1em horizontal margin and 0.5lh vertical margin
  // - white text using newsmallfont
  MRGP_Tooltip GetDefaults() {
    let tt = MRGP_Tooltip(new("MRGP_Tooltip"));
    tt.x = tt.y = 0.0;
    tt.w = 0.3;
    tt.xpad = 1.0;
    tt.ypad = 0.5;
    tt.scale = 1.0;
	tt.x = tt.Cy = 0.0;
    tt.Cw = 0.3;
    tt.Cxpad = 1.0;
    tt.Cypad = 0.5;
    tt.Cscale = 1.0;
    tt.font = newsmallfont;
    tt.colour = Font.CR_WHITE;
    return tt;
  }

  MRGP_Tooltip AppendableTooltip(uint first, uint last) {
    if (tooltips.size() <= 0) return null;
    let tt = tooltips[tooltips.size()-1];
    if (tt.first == first) return tt;
    return null;
  }

  MRGP_Tooltip AddTooltip(uint first, uint last, string tooltip) {
    if (first < 0) ThrowAbortException("Tooltip must have at least one menu item preceding it!");
    let tt = AppendableTooltip(first, last);
    if (tt) {
      // Existing tooltip that we're just appending to.
      tt.text = tt.text .. "\n" .. tooltip;
      return tt;
    }
    // No existing tooltip for these menu entries, create a new one.
    tt = new("MRGP_Tooltip");
    tt.CopyFrom(tooltip_settings);
    tt.first = first;
    tt.last = last;
    tt.text = tooltip;
    tooltips.push(tt);
    return tt;
  }

  MRGP_Tooltip FindTooltipFor(int item) {
    // console.printf("FindTooltipFor(%d)", item);
    if (item < 0 || item >= mDesc.mItems.size()) return null;
    if (!mDesc.mItems[item].Selectable()) return null;
    for (int i = 0; i < tooltips.size(); ++i) {
      if (tooltips[i].first <= item && item <= tooltips[i].last) {
        // console.printf("Found %d <= %d <= %d",
        //   tooltips[i].first, i, tooltips[i].last);
        return tooltips[i];
      }
    }
    return null;
  }

  override void Drawer() {
    super.Drawer();
    let tt = FindTooltipFor(mDesc.mSelectedItem);
    if (tt) tt.Draw();
  }

  // Dynamic tooltip API.
  // TODO: properly think about how the mutable tooltip API should work, including
  // access via the descriptor using the static methods, and release it as a
  // proper update.
  MRGP_Tooltip PushTooltip(String tooltip, uint n=1) {
    if (!tooltip) return null;
    if (n<1) ThrowAbortException("Tooltip must apply to at least one menu item!");
    return AddTooltip(mDesc.mItems.size()-n, mDesc.mItems.size()-1, tooltip);
  }

  // ZScript doesn't have reify, so we just duplicate the CopyTo logic below here.
  void TooltipAppearance(string myfont="", string colour="", string texture="") {
    if (myfont != "") tooltip_settings.font = Font.GetFont(myfont);
    if (colour != "") tooltip_settings.colour = Font.FindFontColor(colour);
    if (texture != "") tooltip_settings.texture = TexMan.CheckForTexture(texture, TexMan.TYPE_ANY);
  }

  void TooltipGeometry(
      double x=-1.0, double y=-1.0, double w=-1.0,
      double xpad=-1.0, double ypad=-1.0, double scale=-1.0) {
    if (x >= 0) tooltip_settings.x = x;
    if (y >= 0) tooltip_settings.y = y;
    if (w >= 0) tooltip_settings.w = w;
    if (xpad >= 0) tooltip_settings.xpad = xpad;
    if (ypad >= 0) tooltip_settings.ypad = ypad;
    if (scale > 0) tooltip_settings.scale = scale;
  }
}

mixin class MRGP_TooltipHolder {
  array<MRGP_Tooltip> tooltips;

  Object Init(array<MRGP_Tooltip> tts) {
    self.tooltips.copy(tts);
    return self;
  }

  override bool Selectable() { return false; }
}

mixin class MRGP_TooltipItem {
  string tooltip;

  Object Init(string tooltip) {
    self.tooltip = tooltip.filter();
    return self;
  }
}

mixin class MRGP_TooltipGeometry {
  double x, y, w, xpad, ypad, scale;

  Object Init(
      double x=-1.0, double y=-1.0, double w=-1.0,
      double xpad=-1.0, double ypad=-1.0,
      double scale=-1.0) {
    self.x = x; self.y = y; self.w = w;
    self.xpad = xpad; self.ypad = ypad;
    self.scale = scale;
    return self;
  }

  void CopyTo(MRGP_Tooltip settings) {
    if (self.x >= 0) settings.x = self.x;
    if (self.y >= 0) settings.y = self.y;
    if (self.w >= 0) settings.w = self.w;
    if (self.xpad >= 0) settings.xpad = self.xpad;
    if (self.ypad >= 0) settings.ypad = self.ypad;
    if (self.scale > 0) settings.scale = self.scale;
  }
}

mixin class MRGP_CVarTipGeometry {
  double Cx, Cy, Cw, Cxpad, Cypad, Cscale;

  Object Init(
      double Cx=-1.0, double Cy=-1.0, double Cw=-1.0,
      double Cxpad=-1.0, double Cypad=-1.0,
      double Cscale=-1.0) {
    self.Cx = Cx; self.Cy = Cy; self.Cw = Cw;
    self.Cxpad = Cxpad; self.Cypad = Cypad;
    self.Cscale = Cscale;
    return self;
  }

  void CopyTo(MRGP_Tooltip settings) {
    if (self.Cx >= 0) settings.Cx = self.Cx;
    if (self.Cy >= 0) settings.Cy = self.Cy;
    if (self.Cw >= 0) settings.Cw = self.Cw;
    if (self.Cxpad >= 0) settings.Cxpad = self.Cxpad;
    if (self.Cypad >= 0) settings.Cypad = self.Cypad;
    if (self.Cscale > 0) settings.Cscale = self.Cscale;
  }
}

mixin class MRGP_TooltipAppearance {
  Font myfont;
  Color colour;
  TextureID texture;

  Object Init(string myfont="", string colour="", string texture="") {
    if (myfont != "") self.myfont = Font.GetFont(myfont);
    if (colour != "") self.colour = Font.FindFontColor(colour);
    if (texture != "") self.texture = TexMan.CheckForTexture(texture, TexMan.TYPE_ANY);
    return self;
  }

  void CopyTo(MRGP_Tooltip settings) {
    if (self.myfont) settings.font = self.myfont;
    if (self.colour) settings.colour = self.colour;
    if (self.texture) settings.texture = self.texture;
  }
}
