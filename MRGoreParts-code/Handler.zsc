/*
	Main frame (or smth idk)
	effects spawning, data handling
*/

Class MR_GoreParticlesStaticHandler: StaticEventHandler
{
	Ui Bool RecsShown;
	Array<MR_GoreParticlesEffect> Effects;
	
	Override Void OnRegister()
	{
		Effects.Clear();
		
		For(int i=0;i<AllClasses.Size();i++)//Caching particle effects data
		{
			if(AllClasses[i] is 'MR_GoreParticlesEffect' && !AllClasses[i].IsAbstract())
			{
				MR_GoreParticlesEffect Clas = MR_GoreParticlesEffect(New(AllClasses[i].GetClassName()));
				Effects.Push(Clas);
			}
		}
		
		if(!MRGoreParts_Debug)Return;
		
		Console.Printf("\cdAll particles blood effects:");
		For(int i=0;i<Effects.Size();i++)Console.Printf("\cg"..i.."\c- "..Effects[i].GetName());
	}
}

Class MR_GoreParticlesHandler: EventHandler
{
	Double Dif(Double a, Double b)
	{
		if(a>b)Return a-b;
		
		Return b-a;
	}
	
	Array<MR_GoreParticlesFlyingBlood> Streams;
	Array<MR_GoreParticlesDeathThinker> Dyings;
	Array<MR_GoreParticlesCrushedThinker> Crushed;
	Array<int> GibsTime;
	Array<MR_GoreParticlesDelayedSpawner> Spawners;
	
	Array<Actor> Wounded;
	Array<MR_GoreParticlesWound> Wounds;
	
	
	
	Array<MR_GoreParticlesEffect> Effects, AlwaysEffects;
	
	Void UpdateEffects()
	{
		MR_GoreParticlesStaticHandler Handler = MR_GoreParticlesStaticHandler(StaticEventHandler.Find("MR_GoreParticlesStaticHandler"));
		
		Effects.Clear();
		
		String TempStr = CVar.FindCVar("MRGoreParts_EffectsList").GetString();
		
		While(TempStr.IndexOf("  ")>-1)
		{
			TempStr.Replace("  ", " ");
		}
		
		While(TempStr.Length()>0)
		{
			String Num;
			if(TempStr.IndexOf(" ")>-1){Num = TempStr.Left(TempStr.IndexOf(" "));TempStr = TempStr.Mid(TempStr.IndexOf(" ")+1);}
			else {Num = TempStr;TempStr = "";}
			
			if(Num.ToInt()>=0 && Num.ToInt()<Handler.Effects.Size())Effects.Push(Handler.Effects[Num.ToInt()]);
		}
		
		AlwaysEffects.Clear();

		TempStr = CVar.FindCVar("MRGoreParts_AlwaysEffectsList").GetString();
		
		While(TempStr.IndexOf("  ")>-1)
		{
			TempStr.Replace("  ", " ");
		}
		
		While(TempStr.Length()>0)
		{
			String Num;
			if(TempStr.IndexOf(" ")>-1){Num = TempStr.Left(TempStr.IndexOf(" "));TempStr = TempStr.Mid(TempStr.IndexOf(" ")+1);}
			else {Num = TempStr;TempStr = "";}
			
			if(Num.ToInt()>=0 && Num.ToInt()<Handler.Effects.Size())AlwaysEffects.Push(Handler.Effects[Num.ToInt()]);
		}
		
		if(!MRGoreParts_Debug)Return;
		
		Console.Printf("\cdRandom effects:");
		For(int i=0;i<Effects.Size();i++)Console.Printf("\cg"..i.."\c- "..Effects[i].GetName());
		Console.Printf("\cdAlways effects:");
		For(int i=0;i<AlwaysEffects.Size();i++)Console.Printf("\cg"..i.."\c- "..AlwaysEffects[i].GetName());
	}
	
	Void UpdateEffectsData()
	{
		MR_GoreParticlesStaticHandler Handler = MR_GoreParticlesStaticHandler(StaticEventHandler.Find("MR_GoreParticlesStaticHandler"));

		For(int i=0;i<Handler.Effects.Size();i++){
			if(Handler.Effects[i])Handler.Effects[i].CountParticles(100);
		}
	}
	
	
	Override Void OnRegister()
	{
		SetUpColors();
		SetUpBlacklist();
		SetUpSounds();
		SetUpBloodRemove();
		UpdateEffects();
	}
	
	Map<String, Color> BldCols;//(Vanilla) monsters that supposed to have different blood color
	
	/*
		MRPRTCOL (MickRomash's gore PaRTiCle COLours) lump stores information
		about blood colours for specific monster classes
		
		Syntax:
		MonsterClassName (R G B)
		
		example:
		HellKnight (10 80 10)
		Cacodemon (30 30 120)
		
		(check filter folder)
	*/
	
	Void SetUpColors()
	{
		BldCols.Clear();
		int LumpNum = 0;
		While(LumpNum>-1)
		{
			int TempLump = Wads.FindLump("MRPRTCOL", LumpNum+1);
			if(TempLump==-1)Break;
			else LumpNum = TempLump;
		}
		
		String Lump = Wads.ReadLump(LumpNum);
		Lump.Replace("\n", "");
		While(Lump.IndexOf("(")>-1)
		{
			String Monster = Lump.Left(Lump.IndexOf(" "));

			String Cols = Lump.Mid(Lump.IndexOf("("), Lump.IndexOf(")")).." ";
			int Vals[3];
			
			For(int i=0;i<3;i++)
			{
				String Temp = Cols.Left(Cols.IndexOf(" "));
				Vals[i] = Temp.ToInt();
				Cols = Cols.Mid(Cols.IndexOf(" ")+1);
			}
			
			if((Class<Actor>)(Monster))BldCols.Insert(Monster, Color(Vals[0],Vals[1],Vals[2]));
			
			Lump = Lump.Mid(Lump.IndexOf(")")+2);
		}
		
		if(MRGoreParts_Debug){
			Console.Printf("\cdBlood color override:");
			Actor Monst;
			Color Col;
			
			Foreach(Monst , Col : BldCols)
			{
				Console.Printf(Monst.." "..Col);
			}
		}
	}
	
	Array< Class <Actor> > BlackList;//List of monsters that shouldn't bleed
	
	Void SetUpBlackList()
	{
		BlackList.Clear();
		String BList = MRGoreParts_BlackList;
		BList.Replace(" ", "");
		While(BList.Length()>2)
		{
			String Monst;
			if(BList.IndexOf(",")>-1)
			{
				Monst = BList.Left(BList.IndexOf(","));
				BList = BList.Mid(BList.IndexOf(",")+1);
			}
			else 
			{
				Monst = BList;
				Blist = "";
			}
			
			
			Class<Actor> MonstCls = Monst;
			if(MonstCls)BlackList.Push(MonstCls);
		}
		
		if(MRGoreParts_Debug){
			Console.Printf("\cdBlacklist:");
			For(int i=0;i<BlackList.Size();i++)Console.Printf("\cg"..BlackList[i].GetClassName());
			Console.Printf("\cd===================");
		}
	}
	
	
	String HitSound, SpraySound, DripSound, GibSound;
	
	Void SetUpSounds()//Utilize gore sounds from other mods, if sfx add-on wasn't loaded
	{
		HitSound = "MRGP/Splash";
		DripSound = "MRGP/Drip";
		GibSound = "MRGP/XDeath";
		SpraySound = "MRGP/Spray";
		
		String Mod;
		
		While(True)
		{
			Mod = 'MRGP_SoundAddon';
			if((Class<Object>)(Mod))Break;
			
			Mod = 'NashGoreActor';//Nashgore next
			if((Class<Actor>)(Mod))
			{
				HitSound = "nashgore/bloodsplash";
				DripSound = "nashgore/gibsmall";
				SpraySound = "nashgore/gibbounce";
				GibSound = "nashgore/xdeath";
				Break;
			}
			
			Mod = 'UG_GibBase';//Universal gibs
			if((class<Actor>)(Mod))
			{
				GibSound = SpraySound = "UGSound/Default";
				Break;
			}
			
			Mod = 'Bolognese_Blood';
			if((class<Actor>)(Mod))
			{
				DripSound = "blooddrop2";
				HitSound = "misc/xdeath2";
				GibSound = "SLOP";
				Break;
			}
			
			Mod = 'Droplets';
			if((Class<Actor>)(Mod))
			{
				HitSound = "blood/hit";
				DripSound = "blood/drip";
				Break;
			}
			
			Mod = 'BrutalHereticImp';//Ketchup V5
			if((Class<Actor>)(Mod))
			{
				DripSound = "blooddrop2";
				HitSound = "misc/xdeath2";
				GibSound = "misc/xdeath4";
				Break;
			}
			
			Mod = 'Doomer';//Brutal Dewm
			if((Class<Actor>)(Mod))
			{
				DripSound = "blooddrop2";
				HitSound = "misc/xdeath2";
				GibSound = "misc/xdeath4";
				Break;
			}
			
			Mod = 'PileOfGibs';//Splatter gore
			if((Class<Actor>)(Mod))
			{
				SpraySound = "Gore/Squish";
				GibSound = "Gore/GIBSPLAT";
				Break;
			}
			
			Break;
		}
		if(MRGoreParts_Debug){
			Console.printf("\n\cgSounds:");
			Console.Printf("\ccHitSound:\cg \""..HitSound.."\"");
			Console.Printf("\ccDripSound:\cg \""..DripSound.."\"");
			Console.Printf("\ccSpraySound:\cg \""..SpraySound.."\"");
			Console.Printf("\ccGibSound:\cg \""..GibSound.."\"");
		}
	}
	
	
	Array<String> RemoveBloods, RemoveBloodTypes;
	String RemoveBloodBase;
	
	Void SetUpBloodRemove()//Caching blood actors that will be hidden/removed
	{
		RemoveBloods.Clear();
		RemoveBloodTypes.Clear();
		
		For(int i=0;i<AllActorClasses.Size();i++)
		{
			String Blud = GetDefaultByType(AllActorClasses[i]).BloodType;
			if(Blud!="Blood" && RemoveBloodTypes.Find(Blud)==RemoveBloodTypes.Size())RemoveBloodTypes.Push(Blud);
			
			Blud = GetDefaultByType(AllActorClasses[i]).BloodType2;
			if(Blud!="BloodSplatter" && RemoveBloodTypes.Find(Blud)==RemoveBloodTypes.Size())RemoveBloodTypes.Push(Blud);
			
			Blud = GetDefaultByType(AllActorClasses[i]).BloodType3;
			if(Blud!="AxeBlood" && RemoveBloodTypes.Find(Blud)==RemoveBloodTypes.Size())RemoveBloodTypes.Push(Blud);
		}
		
		String Mod;
		While(True)
		{
			Mod = 'NashGoreActor';//Nashgore next
			if((Class<Actor>)(Mod))
			{
				Break;
			}
			
			Mod = 'UG_GibBase';//Universal gibs
			if((class<Actor>)(Mod))
			{
				RemoveBloodBase = 'UG_GibImpactBlood';
				Break;
			}
			
			Mod = 'Bolognese_Blood';
			if((class<Actor>)(Mod))
			{
				RemoveBloodBase = 'BD_FlyingBlood';
				RemoveBloods.Push('SuperGore');
				RemoveBloods.Push('BD_FlyingBloodTrail');
				Break;
			}
			
			Mod = 'Droplets';
			if((Class<Actor>)(Mod))
			{
				RemoveBloodBase = 'BloodHitPuff';
				Break;
			}
			
			Mod = 'BrutalHereticImp';//Ketchup V5
			if((Class<Actor>)(Mod))
			{
				RemoveBloodBase = 'Brutal_Blood';
				RemoveBloods.Push('TinyBlood');
				RemoveBloods.Push('BloodHit');
				RemoveBloods.Push('Brutal_FlyingBlood');
				RemoveBloods.Push('Brutal_FlyingBloodFake');
				Break;
			}
			
			Mod = 'HDOperator';//Hideous destructor
			if((Class<Actor>)(Mod))
			{
				RemoveBloodBase = 'BloodSplatSilent';
				RemoveBloods.Push('HDBloodTrailFloor');
				Break;
			}
			
			Mod = 'Doomer';//Brutal Dewm
			if((Class<Actor>)(Mod))
			{
				RemoveBloodBase = 'Brutal_Blood';
				RemoveBloods.Push('BloodSplasher');
				RemoveBloods.Push('BlueBloodSplasher');
				RemoveBloods.Push('GreenBloodSplasher');
				RemoveBloods.Push('Brutal_FlyingBlood');
				Break;
			}
					
			/*Mod = 'PileOfGibs';//Splatter gore
			if((Class<Actor>)(Mod))
			{
				Break;
			}*/
			
			Break;
		}
		if(MRGoreParts_Debug){
			Console.Printf("\cgBase Blood: "..RemoveBloodBase);
			Console.Printf("\cgBlood Types:");
			For(int i=0;i<RemoveBloodTypes.Size();i++)Console.Printf(i.." "..RemoveBloodTypes[i]);
			Console.Printf("\cgBloods:");
			For(int i=0;i<RemoveBloods.Size();i++)Console.Printf(i.." "..RemoveBloods[i]);
			Console.Printf("-----------");
		}
	}
	
	Float ViewBob;
	
	Void ThinkersTick()
	{
		For(int i=0;i<Streams.Size();i++){
			if(Streams[i])Streams[i].Tick();
		}
		
		For(int i=0;i<GibsTime.Size();i++){//Not a thinker actually, but who cares
			GibsTime[i]++;
			if(GibsTime[i]>(MRGP_GibbingTime/MRGoreParts_Speed)){GibsTime.Delete(i);i--;}
		}
		
		For(int i=0;i<Dyings.Size();i++){
			if(Dyings[i])Dyings[i].Tick();
		}
		
		For(int i=0;i<Crushed.Size();i++){
			if(Crushed[i])Crushed[i].Tick();
		}
		
		For(int i=0;i<Wounds.Size();i++){
			if(Wounds[i])Wounds[i].Tick();
		}
		
		For(int i=0;i<Spawners.Size();i++){
			if(Spawners[i])Spawners[i].Tick();
		}
	}
	
	Override Void WorldTick()
	{
		ThinkersTick();
		
		/////////////////////////////
				
		if(!MRGoreParts_CheckLimit)Return;
		Let Plr = Players[ConsolePlayer].Camera;
		if(!Plr)Return;
		
		Vector3 Pos = (0,0, Plr.Player.ViewZ-Plr.Pos.Z);
		Pos.XY += Actor.AngleToVector(Plr.Angle+90, -MRGoreParts_CheckLimitOffset + 1*Abs(Sin(Plr.Pitch)));
		
		Float NewBob = Plr.Player.ViewZ - Plr.Pos.Z - Plr.Player.ViewHeight;
		Float Bob;
		Bob = Actor.DeltaAngle(ViewBob, NewBob);
		
		Pos += (Actor.AngleToVector(Plr.Angle, 4)*Cos(Abs(Plr.Pitch)),Abs(Cos(Plr.Pitch))*2.3 -Sin(Plr.Pitch)*4);
		Pos.XY += Actor.AngleToVector(Plr.Angle, 3.4)*Sin(Plr.Pitch);
		
		
		if(GameTic%4==0)
			Plr.A_SpawnParticle(Color(0,150,0), SPF_FULLBRIGHT, 1, .5, 0, Pos.X,Pos.Y,Pos.Z-Bob -Plr.Vel.Z*1.3,
				Plr.Vel.X,Plr.Vel.Y,Bob +Plr.Vel.Z*1.3, FadeStepf:0);
			
		ViewBob = NewBob;
	}
	
	Bool MRGPartsCheckDraw(Actor mo = Null)
	{
		if(!MRGoreParts_Draw)Return false;
		
		Let Plr = Players[ConsolePlayer].Camera;
		if(!Plr)Return true;
		
		if(!mo)Return true;
		
		
		Return (abs(Actor.DeltaAngle(Plr.Angle, Plr.AngleTo(mo)))<CVar.FindCVar("FOV").GetFloat()||Plr.Distance2D(mo)<Plr.Radius*2) && mo.CheckSight(Plr);
	}
	
	Void SpawnNoBlood(Actor mo, Actor inflictor, Double Angle, Actor Source = Null, Bool HDestArmor = false)//Spec. effects for non bleeding actors
	{
		if(MRGoreParts_NoBloodMist)
		{
			Actor Who = mo;
			Double ZOfst = mo.Height*.5;
			if(Inflictor&&Inflictor.Distance2D(mo)<mo.Radius*1.5){Who = Inflictor; Angle = Who.AngleTo(mo)+180; ZOfst = 0;}

			Float Bright = CFRandom(.7, 1.4);
			
			Color Col = MRGoreParts_NoBloodMistColor;

			Col = Color(int(Col.R*Bright), int(Col.G*Bright), int(Col.B*Bright));
			
			MR_GoreParticlesEffect.SpawnEffect('MR_GoreParticlesEffect_Mist', Who, 0, Angle, Who.Pos.Z/(mo.Pos.Z+mo.Height*.5)*90, Col, Offset:(0,0,ZOfst));
		}
		if(HDestArmor)
		{
			Actor Who = mo;
			Double ZOfst = mo.Height*.5;
			if(Inflictor&&Inflictor.Distance2D(mo)<mo.Radius*1.5){Who = Inflictor; Angle = Who.AngleTo(mo)+180; ZOfst = 0;}
			
			Double Pitch = 0;
			if(Source && PlayerPawn(Source) && Inflictor)Pitch = Inflictor.PitchTo(Source, 5, Source.Player.ViewZ-Source.Pos.Z);
			Pitch = 0;
			
			MR_GoreParticlesEffect.SpawnEffect('MR_GoreParticlesEffect_Sparks', Who, 0, Angle, Who.Pos.Z/(mo.Pos.Z+mo.Height*.5)*-90, Offset:(0,0,ZOfst));
		}
	}
	
	Void SpawnWound(Actor Thing=Null, Actor Inflictor=Null, Actor DamageSource=Null, Color Col=Color(0,0,0))
	{
		MR_GoreParticlesWound Token;//Wound thinker we're working with
		if(Wounded.Find(Thing)==Wounded.Size())//In case actor hasn't been wounded before, create a new wound thinker
		{
			MR_GoreParticlesWound a = New('MR_GoreParticlesWound');
			a.Owner = Thing;
			a.PostBeginPlay();
			Token = a;
		}
		else//Otherwise, work with wound thinker linked to this actor
		{
			if(Wounded.Find(Thing)>=Wounds.Size())Return;
			Token = Wounds[Wounded.Find(Thing)];
		}
		
		if(!Token){if(MRGoreParts_Debug)Console.Printf("Couldn't find or create a wound for "..Thing.GetClassName().." at "..Thing.Pos);Return;}
		
		Token.Col = Col;
		
		if(Inflictor != Thing && Inflictor != DamageSource)//Check if it wasn't SH (like bleeding in HDest)
		{
			Bool Replace = true;//Check wounds limit
			For(int i=0;i<MRGoreParts_MaxWounds;i++)
			{
				if(Token.Ages[i]<1)
				{
					if(MRGoreParts_Debug)Console.Printf("\cdTarget pos:\cc "..Thing.Pos.XY.."\cg inflict pos:\cc "..Inflictor.Pos.XY);
					Vector3 Dif = LevelLocals.Vec3Diff(Inflictor.Pos, Thing.Pos);
	
					Vector3 Home = (0, 0, 0);
					
					Home.Y -= Dif.X*Cos(Thing.Angle-90) + Dif.Y*Sin(Thing.Angle-90);
					Home.X -= Dif.X*Cos(Thing.Angle) + Dif.Y*Sin(Thing.Angle);
					
					Home.XY *= .75;
					
					Home.X *= abs(Cos(Actor.DeltaAngle(Thing.Angle, Thing.AngleTo(Inflictor))));
					Home.Y *= abs(Sin(Actor.DeltaAngle(Thing.Angle, Thing.AngleTo(Inflictor))));

					Home.Z = -Dif.Z+5;
					Home.Z = Home.Z/Thing.Height;
					
					if(Home.X>0)Home.X = Min(Home.X, Thing.Radius);
					else Home.X = Max(Home.X, -Thing.Radius);
					
					if(Home.Y>0)Home.Y = Min(Home.Y, Thing.Radius);
					else Home.Y = Max(Home.Y, -Thing.Radius);
					
					Token.Locs[i]=Home;
					Token.Angles[i]=Thing.AngleTo(Inflictor);
					Token.Ages[i]=35*15;
					Replace = false;
					Break;
				}
			}
			if(Replace)//Replace the oldest wound on actor
			{
				if(MRGoreParts_Debug)Console.Printf("Targ "..Thing.Pos.XY.." inf "..Inflictor.Pos.XY);
				Vector3 Dif = LevelLocals.Vec3Diff(Inflictor.Pos, Thing.Pos);

				Vector3 Home = (0, 0, 0);
				
				Home.Y -= Dif.X*Cos(Thing.Angle-90) + Dif.Y*Sin(Thing.Angle-90);
				Home.X -= Dif.X*Cos(Thing.Angle) + Dif.Y*Sin(Thing.Angle);
				
				Home.XY *= .75;
				
				Home.X *= abs(Cos(Actor.DeltaAngle(Thing.Angle, Thing.AngleTo(Inflictor))));
				Home.Y *= abs(Sin(Actor.DeltaAngle(Thing.Angle, Thing.AngleTo(Inflictor))));

				Home.Z = -Dif.Z+5;
				Home.Z = Home.Z/Thing.Height;
				
				if(Home.X>0)Home.X = Min(Home.X, Thing.Radius);
				else Home.X = Max(Home.X, -Thing.Radius);
				
				if(Home.Y>0)Home.Y = Min(Home.Y, Thing.Radius);
				else Home.Y = Max(Home.Y, -Thing.Radius);
				
				Token.Locs[0]=Home;
				Token.Angles[0]=Thing.AngleTo(Inflictor);
				Token.Ages[0]=35*15;
			}
		}
		else//Hideous bleeding
		{
			Array<int> Ages;
			For(int i=0;i<MRGoreParts_MaxWounds;i++)
			{
				if(Token.Ages[i]>0)
				{
					Ages.Push(i);
				}
			}
			
			if(Ages.Size()>0)Token.Ages[Ages[CRandom(0, Ages.Size()-1)]]=1;
			
			else
			{
				Token.Ages[0]=35*15;
				Token.Locs[0]=(Actor.AngleToVector(CRandom(0, 360), Thing.Radius*.3), CFRandom(.15, 1));
			}
		}
	}
		
	////
	//// EVENTS
	////
	
	Override Void WorldThingDamaged(WorldEvent e)
	{
		if(e.Thing.bIsMonster||e.Thing is 'PlayerPawn'||e.Thing.bCorpse)
		{
			if((e.Thing.bNoBlood && !MRGoreParts_NoBloodMonsters) || (MRGoreParts_BlacklistOn && BlackList.Find(e.Thing.GetClass())!=BlackList.Size()))
			{
				SpawnNoBlood(e.Thing, e.Inflictor, e.DamageAngle);//Special effects for non bleeding actors
				Return;
			}
			
			if(MRGoreParts_BlacklistOn)
				For(int i=0;i<BlackList.Size();i++){
					if(e.Thing is BlackList[i]){SpawnNoBlood(e.Thing, e.Inflictor, e.DamageAngle);Return;}
				}
			
			if(MRGoreParts_Debug){
				String Damage = "";
				if(e.DamageFlags&DMG_EXPLOSION)Damage = Damage.."Explosion|";
				if(e.DamageFlags&DMG_USEANGLE)Damage = Damage.."Use_Angle|";
				if(e.DamageFlags&DMG_INFLICTOR_IS_PUFF)Damage = Damage.."IsPuff|";
				Console.Printf("Damage: "..e.DamageType.." Flags: "..Damage);
				if(e.DamageSource)Console.Printf("Source: "..e.DamageSource.GetClassName().." "..e.DamageSource.Pos);
				if(e.Inflictor && e.Inflictor!=e.DamageSource)Console.Printf("Inflictor: "..e.Inflictor.GetClassName().." "..e.Inflictor.Pos);
			}
			
			String HDest = 'HDOperator';
			if((Class<Actor>)(HDest))
			{
				String Armour = "HDArmourWorn";
				if(e.DamageType == 'bashing' && e.Thing.CountInv(Armour))
				{
					SpawnNoBlood(e.Thing, e.Inflictor, e.DamageAngle, e.DamageSource, true);
					Return;
				}
				if(e.DamageType != 'piercing' && e.DamageType != 'bleedout')Return;
			}
			
			Float Amount = MRGoreParts_Amount;
				
			Color Col = e.Thing.BloodColor;
			if(MRGoreParts_UseCustomColor)
			{
				Col = MRGoreParts_Color;
			}
			else
			{
				if(e.Thing.BloodColor==0 && e.Thing.BloodTranslation==0)Col = GameInfo.defaultbloodcolor;
				if(BldCols.CheckKey(e.Thing.GetClassName()))Col = BldCols.Get(e.Thing.GetClassName());
			}
			
			if(e.DamageType == 'bleedout')
			{
				Vector3 Pos = (Actor.AngleToVector(e.Thing.Angle + CFRandom(-90, 90), e.Thing.Radius*.7), CRandom(e.Thing.Height*.25, e.Thing.Height*.7));
				
				For(int i=0;i<CRandom(2, 4);i++)
				e.Thing.A_SpawnParticle(Col, 0, 20, CFRandom(2, 3), 0, Pos.X,Pos.Y,Pos.Z+.1*i,
					0,0,0, 0,0,-.3);
				MR_GoreParticlesEffect.SpawnEffect('MR_GoreParticlesEffect_SimpleSplash', e.Thing, 0, e.DamageAngle, 0, Col, 1, .6, 1, Pos);
			}
			
			if(e.Inflictor)
			{
				//Console.Printf("\cdHealth: \c-"..e.Thing.Health.." \cgDamage: \c-"..e.Damage);
				//Console.Printf("Damage: "..e.DamageType.." Flags: "..Damage);
				
				if(MRGoreParts_Wounds && !PlayerPawn(e.Thing) && (Wounded.Find(e.Thing)!=Wounded.Size() || Wounded.Size()<MRGoreParts_MaxWounded) && e.DamageType != 'bleedout' && CRandom(0, 10)>4)
				{
					SpawnWound(e.Thing, e.Inflictor, e.DamageSource, Col);
				}
				
				if(e.Inflictor != e.Thing)//Spawn effects
				{
					if(!e.DamageSource)Return;
					Double Pitch = 0;
					if(e.DamageSource && e.DamageSource.Player)Pitch = e.Inflictor.PitchTo(e.DamageSource, 5, e.DamageSource.Player.ViewZ-e.DamageSource.Pos.Z);
					else if(e.DamageSource)Pitch = e.Inflictor.PitchTo(e.DamageSource, 0, e.DamageSource.Height*.9);
					
					Let Spot = e.Inflictor;
					Double VOfst = 0;
					Double DifZ = Dif(Spot.Pos.Z, e.Thing.pos.Z+e.Thing.Height*.5);

					if(e.Inflictor.Distance2D(e.Thing)>e.Thing.Radius*1.5||DifZ>e.Thing.Height*.5){Spot = e.Thing;VOfst = e.Thing.Height*.5;}
					
					int Fuzzy = 0;
					if(MRGoreParts_FuzzyBlood && (e.Thing.GetRenderStyle() == STYLE_OptFuzzy||e.Thing.GetRenderStyle() == STYLE_Fuzzy))Fuzzy = SGPF_Fuzzy;
					
					if(Effects.Size()>0)
						Effects[CRandom(0, Effects.Size()-1)].DoParticleEffect(Spot, Fuzzy, Spot.AngleTo(e.DamageSource), Pitch, Col, offset:(0,0,VOfst));
					For(int i=0;i<AlwaysEffects.Size();i++)
					{
						AlwaysEffects[i].DoParticleEffect(Spot, Fuzzy, Spot.AngleTo(e.DamageSource), Pitch, Col, Offset:(0,0,VOfst));
					}
					
					if(Random(0, 50)>40)e.Inflictor.A_StartSound(DripSound, CHAN_AUTO, Volume:MRGoreParts_SndVol);
					e.Inflictor.A_StartSound(HitSound, CHAN_AUTO, Volume:MRGoreParts_SndVol);


					if(MRGoreParts_DrawFlyingBlood && CRandom(0, 100)>95)
					{
						Float Strn = CRandom(4, 6);
						Float Pitch = -CRandom(0, 60);
						Vector3 Vel = (Actor.AngleToVector(e.Inflictor.AngleTo(e.DamageSource)+CRandom(-50, 50), Strn)*Cos(Pitch), -Sin(Pitch)*Strn);
						MR_GoreParticlesFlyingBlood.Create(e.Inflictor.Pos, Col, Fuzzy, Scale:4*CFRandom(1, 2), Vel:Vel);
						S_StartSoundAt(e.Inflictor.Pos, SpraySound, CHAN_AUTO, Volume: CFRandom(.2, .3)*MRGoreParts_SndVol, Pitch: CFrandom(1.1, 1.2));
					}
					//Dripping blood
					if(MRGPartsCheckDraw(e.Inflictor) && MRGoreParts_DripOnImpact)
						For(int i=CRandom(0, 5)*Amount;i<10*Amount;i++){
							Float Dist = 1;
							if(e.DamageSource)Dist *= 1+(e.Inflictor.Distance3D(e.DamageSource)-80)*.0025;
							Float Size = CFRandom(.8, 1.6)*Dist;
							Float Pitch = e.Inflictor.Pos.Z/e.Thing.Height+CRandom(10, 20);
							if(e.Inflictor is 'BulletPuff' && e.DamageSource)Pitch = e.DamageSource.Pitch+CRandom(10, 20);
							Float Ang = CRandom(175, 185);
							Float Angle = e.Inflictor.AngleTo(e.Thing)+Ang;
							if(e.Inflictor is 'BulletPuff' && e.DamageSource)Angle = e.Inflictor.AngleTo(e.DamageSource)+180+Ang;
							Vector3 Ofst = (Actor.AngleToVector(Angle, 1)*abs(Cos(Pitch)), Sin(Pitch))*Dist;
									
							Ang = CRandom(140, 220)*Dist;
							Angle = e.Inflictor.AngleTo(e.Thing)+Ang;
							if(e.Inflictor is 'BulletPuff' && e.DamageSource)Angle = e.Inflictor.AngleTo(e.DamageSource)+180+Ang;
							Float Bright = MRGoreParts_Brightness*CFrandom(.9, 2);
							Color ColTmp = Color(int(Col.R*Bright), int(Col.G*Bright), int(Col.B*Bright));
							e.Inflictor.A_SpawnParticle(ColTmp, Fuzzy, CRandom(29, 40), Size*1.3, 0, Ofst.X*2,Ofst.Y*2,5,
									0,0,CFRandom(0, 1), 0,0,-.2, 1, 0, -Size/40);
						}
				}
			}
		}
	}
	
	Override Void WorldThingDied(WorldEvent e)
	{
		if(!e.Thing||!(e.Thing.bIsMonster || e.Thing is 'PlayerPawn')||(e.Thing.bNoBlood && !MRGoreParts_NoBloodMonsters)||
			(BlackList.Find(e.Thing.GetClass())!=BlackList.Size()&&MRGoreParts_BlacklistOn) )Return;
		
		if(MRGoreParts_BlacklistOn)For(int i=0;i<BlackList.Size();i++){if(e.Thing is BlackList[i])Return;}
		
		Color Col = e.Thing.BloodColor;
		if(MRGoreParts_UseCustomColor)
		{
			Col = MRGoreParts_Color;
		}
		else
		{
			if(e.Thing.BloodColor==0 && e.Thing.BloodTranslation==0)Col = GameInfo.defaultbloodcolor;
			if(BldCols.CheckKey(e.Thing.GetClassName()))Col = BldCols.Get(e.Thing.GetClassName());
		}
		
		Float Amount = MRGoreParts_Amount;

		if(e.Thing.FindState("XDeath") && e.Thing.Health<-GetDefaultByType(e.Thing.GetClass()).Health)
		{
			SpawnXDeath(e.Thing, e.Inflictor);
		}
		else if(MRGoreParts_MaxDying>0)
		{
			MR_GoreParticlesDeathThinker a = New('MR_GoreParticlesDeathThinker');
			a.Owner = e.Thing;
			a.PostBeginPlay();
			a.Bld = Col;
			a.Artery = Max(0, CRandom(-5, 2));
			
			if(Dyings.Size()>=MRGoreParts_MaxDying)
			{
				Dyings[0].Destroy();
			}
			
			Dyings.Push(a);
		}
	}
	
	Override void WorldThingGround (WorldEvent e)//Crush
	{
		if(MRGoreParts_Crush<1)Return;
		
		if(!e.Thing)Return;
		if(!e.Thing.bIsMonster&&!e.Thing.bCorpse)Return;
		
		if(MRGoreParts_Debug)Console.Printf(e.Thing.GetClassName().." at "..e.Thing.Pos.." Crushed! (ceiling: "..e.Thing.CeilingZ..")");

		Color Col = e.Thing.BloodColor;
		if(MRGoreParts_UseCustomColor)
		{
			Col = MRGoreParts_Color;
		}
		else
		{
			if(e.Thing.BloodColor==0 && e.Thing.BloodTranslation==0)Col = GameInfo.defaultbloodcolor;
			if(BldCols.CheckKey(e.Thing.GetClassName()))Col = BldCols.Get(e.Thing.GetClassName());
		}
		
		Sector Crusher;
		
		Float Radius = GetDefaultByType(e.Thing.GetClass()).Radius*1.5;
		
		Float Lowest, CeilingZ;
		CeilingZ = e.Thing.CeilingZ;
		
		For(int x = e.Thing.Pos.X-Radius;x<e.Thing.Pos.X+Radius;x+=5)
		{
			For(int Y = e.Thing.Pos.Y-Radius;Y<e.Thing.Pos.Y+Radius;Y+=5)
			{
				Sector TempSect = LevelLocals.PointInSector((X,Y));
				
				if(TempSect.CenterCeiling()!=CeilingZ)Continue;
				
				if(TempSect.PlaneMoving(1)){Crusher = TempSect;Break;}
			}
			if(Crusher)Break;
		}
		
		MR_GoreParticlesCrushedThinker Nerd = New('MR_GoreParticlesCrushedThinker');
		
		Nerd.Radius = Radius;
		Nerd.Pos = e.Thing.Pos.XY;
		Nerd.Bld = Col;
		
		int Fuzzy = 0;
		if(MRGoreParts_FuzzyBlood && (e.Thing.GetRenderStyle() == STYLE_OptFuzzy||e.Thing.GetRenderStyle() == STYLE_Fuzzy))Fuzzy = STYLE_Shadow;
		
		Nerd.RenderStyle = Fuzzy;
		Nerd.CurSector = Crusher;
				
		Nerd.PostBeginPlay();
		
		e.Thing.A_StartSound(GibSound, CHAN_AUTO, Volume: .5*MRGoreParts_SndVol);
		
		if(Crushed.Size()>=MRGoreParts_Crush){
			if(Crushed[0])Crushed[0].DropAll();
		}
		
		if(!MRGoreParts_Draw)Return;
		
		Double Size = GetDefaultByType(e.Thing.GetClass()).Height;
		if(Size<GetDefaultByType(e.Thing.GetClass()).Radius)Size = GetDefaultByType(e.Thing.GetClass()).Radius;
		MR_GoreParticlesEffect.SpawnEffect('MR_GoreParticlesEffect_Mist', e.Thing, SGPF_NoDist|SGPF_FixAmount|SGPF_NoVel|Fuzzy, CFRandom(0, 360), 0, Col, 1, Size, 2, (0,0,e.Thing.Height*.5), 2, 1/(e.Thing.Mass*.1));
		
		
		For(int i=0;i<CRandom(40, 50)*MRGoreParts_Amount;i++){//Floor splash
			Float Bright = MRGoreParts_Brightness*CFRandom(.5, 1.5);
			Color ColTemp = Color(int(Col.R*Bright),int(Col.G*Bright),int(Col.B*Bright));
			Double Size = GetDefaultByType(e.Thing.GetClass()).Radius*GetDefaultByType(e.Thing.GetClass()).Height;
			Size *= .05;
			Size *= FRandom(.5, 1.5);
			e.Thing.A_SpawnParticleEx(ColTemp, Texman.CheckForTexture("glpart1"), Fuzzy, SPF_RELATIVE, 130, Size, Random(0, 360),
				0,0,1, CFRandom(.6, 1),0,-.005, -CFRandom(.001, .005),0,0, 1, 0, -(Size/130.));
		}
	}
	
	
	Override Void WorldThingSpawned(WorldEvent e)
	{
		if(!MRGoreParts_OnlyModsBlood&&!MRGoreParts_HideOtherBlood)Return;
		if(!e.Thing)Return;
		
		if(e.Thing is 'Blood'||e.Thing is 'BloodSplatter'||e.Thing is 'AxeBlood'||Actor.GetReplacement("Blood")==e.Thing.GetClass()
			||e.Thing is RemoveBloodBase)
		{
			DoOtherBlood(e.Thing);
			Return;
		}
		
		if(MRGoreParts_BloodTypes)For(int i=0;i<RemoveBloodTypes.Size();i++)
		{
			if(e.Thing is RemoveBloodTypes[i]){DoOtherBlood(e.Thing);Return;}
		}
		
		For(int i=0;i<RemoveBloods.Size();i++)
		{
			if(e.Thing is RemoveBloods[i]){DoOtherBlood(e.Thing);Return;}
		}
		
		//Console.Printf(e.Thing.GetClassName());
	}
	
	Void SpawnBloodDrop(Actor mo, Color Col)//Mainly for hdest
	{
		Bool Draw = MRGoreParts_Draw;
		
		Float TempGrav = -.3;
		
		if(Draw)For(int i=0;i<CRandom(2, 5);i++)
			mo.A_SpawnParticle(Col, 0, 20, CFRandom(3, 4), 0, CFRandom(-.5,.5),CFRandom(-.5,.5),.1*i, mo.Vel.X,mo.Vel.Y,0, 0,0,TempGrav);
		
		MR_GoreParticlesDelayedSpawner a = New('MR_GoreParticlesDelayedSpawner');
		
		a.PostBeginPlay();
		
		int Delay = 1;
		For(float i=mo.Pos.Z;i>mo.floorZ;i-=TempGrav)
		{
			TempGrav += abs(-.3);
			Delay++;
		}
		
		Double Alph = FRandom(.8, .9);
		a.Pos = (mo.pos.x+frandom(-1, 1), mo.pos.y+frandom(-1, 1), mo.floorz);
		a.Col = Col;
		a.Size = FRandom(2, 4);
		a.Delay = Delay;
		a.Life = 150;
		a.Fade = Alph/100;
		a.Alpha = Alph;
		a.Ofst = (0,0,1);
		a.PlaySound = true;
	}
	
	Void SpawnXDeath(Actor mo, Actor inflictor = Null)
	{
		mo.A_StartSound(GibSound, CHAN_AUTO, Volume:MRGoreParts_SndVol);
		
		if(GibsTime.Size()>=MRGoreParts_MaxGibing)Return;
		
		int Fuzzy = 0;
		if(MRGoreParts_FuzzyBlood && (mo.GetRenderStyle() == STYLE_OptFuzzy||mo.GetRenderStyle() == STYLE_Fuzzy))Fuzzy = SGPF_Fuzzy;
		
		Color Col = mo.BloodColor;
		if(MRGoreParts_UseCustomColor)
		{
			Col = MRGoreParts_Color;
		}
		else
		{
			if(mo.BloodColor==0 && mo.BloodTranslation==0)Col = GameInfo.defaultbloodcolor;
			if(BldCols.CheckKey(mo.GetClassName()))Col = BldCols.Get(mo.GetClassName());
		}
		
		Let Plr = Players[ConsolePlayer].Camera;
		Bool Draw = true;
		if(Plr)Draw = abs(Actor.deltaangle(Plr.AngleTo(mo), Plr.Angle))<CVar.FindCVar("FOV").GetFloat()||Plr.Distance2D(mo)<Plr.Radius*2;
		
		Float Amount = MRGoreParts_Amount;
		
		GibsTime.Push(0);
		
		Float Angle = CRandom(0, 360);
		
		if(Inflictor)Angle = mo.AngleTo(Inflictor)+CRandom(-60, 60);
		
		if(Draw){
			Double Size = mo.Height;
			if(mo.Height<mo.Radius)Size = mo.Radius;
			MR_GoreParticlesEffect.SpawnEffect('MR_GoreParticlesEffect_Mist', mo, SGPF_NoDist|SGPF_FixAmount|SGPF_NoVel|Fuzzy, Angle+CRandom(-120, 120), 0, Col, 1, Size, 2, (0,0,mo.Height*.5), 2, 1/(mo.Mass*.1));
		
			For(int i=0;i<Amount*CRandom(8, 12);i++)
			{
				if(Effects.Size()>0)
					Effects[CRandom(0, Effects.Size()-1)].DoParticleEffect(mo, Fuzzy, Angle+CRandom(-120, 120), CRandom(-20, 0)*4, Col, 1.1, 4, 1,
						(CRandom(-mo.Radius, mo.Radius)*.5,CRandom(-mo.Radius, mo.Radius)*.5,CRandom(10, mo.Height*.5)), 4, 1/(mo.Mass*.1));
			}
			
			For(int i=0;i<CRandom(30, 40)*MRGoreParts_Amount;i++){//Floor splash
				Float Bright = MRGoreParts_Brightness*CFRandom(.5, 1.5);
				Color ColTemp = Color(int(Col.R*Bright),int(Col.G*Bright),int(Col.B*Bright));
				Double Size = GetDefaultByType(mo.GetClass()).Radius*GetDefaultByType(mo.GetClass()).Height;
				Size *= .04;
				Size *= FRandom(.5, 1.5);
				mo.A_SpawnParticleEx(ColTemp, Texman.CheckForTexture("glpart1"), Fuzzy, SPF_RELATIVE, 100, Size, Random(0, 360),
					0,0,1, CFRandom(2, 3),0,-.05, -.03,0,0, 1, 0, -(Size/100.));
				}
		}
				
		if(MRGoreParts_DrawFlyingBlood){
			int SAmount;
			For(int i=0;i<CRandom(9, 12);i++)
			{
				if(SAmount>5*Amount)Break;
				Float Strn = CRandom(5, 7);
				Float Pitch = -CRandom(40, 90);
				Vector3 Vel = (Actor.AngleToVector(Angle+CRandom(-120, 120), Strn)*Cos(Pitch), -Sin(Pitch)*Strn);
				MR_GoreParticlesFlyingBlood.Create(mo.Pos, Col, Fuzzy, Scale:4*CFRandom(1, 2), Vel:Vel);
				mo.A_StartSound(SpraySound, CHAN_AUTO, Volume: CFRandom(.1, .3)*MRGoreParts_SndVol, Pitch: CFrandom(1.1, 1.2));
				SAmount++;
			}
		}
		
	}
	
	Void DoOtherBlood(Actor mo)//Remove or hide other mods gore
	{
		Color Col = Gameinfo.DefaultBloodColor;
		if(MRGoreParts_UseCustomColor)
		{
			Col = MRGoreParts_Color;
		}
		
		String HDBld = 'HDBloodTrailFloor';
		if((Class<Actor>)(HDBld))
		{
			if(mo is HDBld)
			{
				Double Alph = CFRandom(.8, 1);
				mo.A_SpawnParticle(Col, 0, 100, CRandom(2, 3), 0, 0,0,1,
					0,0,0, 0,0,0, Alph, Alph/100.);
				if(MRGoreParts_OnlyModsBlood)mo.Destroy();
				Return;
			}
			
			HDBld = 'BloodSplat';
			String HDBld2 = 'HDMasterBlood';
			if(mo is HDBld2||mo is HDBld)
			{
				String Sheild = 'HDMagicShield';
				if(mo is HDBld2 && mo.Target && mo.Target.CountInv(Sheild)>0 && !mo.bnobouncesound)Return;
				
				if(mo.Target && (mo.Target.BloodTranslation!=0||mo.Target.BloodColor!=0))Col = mo.Target.BloodColor;
				SpawnBloodDrop(mo, Col);
				if(MRGoreParts_OnlyModsBlood)mo.Destroy();
				Return;
			}
		}
		
		if(MRGoreParts_Draw && MRGoreParts_Quake2 && Players[ConsolePlayer].Camera){
			
			int Glow = 0;
			if(MRGoreParts_FullBright)Glow = SPF_FULLBRIGHT;
			For(Int i=0;i<CRandom(6, 9)*MRGoreParts_Amount;i++)
			{
				Float Bright = MRGoreParts_Brightness*CFrandom(.8, 1.5);
				mo.A_SpawnParticle(Color(int(col.r*Bright), int(col.g*Bright), int(col.b*Bright)), SPF_RelVel|Glow, 25, CFRandom(1.5, 2.5)*MRGoreParts_Size, mo.AngleTo(Players[ConsolePlayer].Camera),
					Xoff:CFRandom(-1.5, 1.5),CFRandom(-1.5, 1.5),CFRandom(4, 7), .1*MRGoreParts_Speed,0,.5*MRGoreParts_Speed, 0,0, -.05*MRGoreParts_Size*MRGoreParts_Speed);
			}
		}
		
		if(MRGoreParts_OnlyModsBlood){mo.Destroy();Return;}
		
		mo.A_SetRenderStyle(0, STYLE_NONE);
	}
	

	
	Override Void NetworkProcess(ConsoleEvent e)
	{
		if(e.name ~== "MRGP_UpdateEffects"){
			UpdateEffects();
			Return;
		}
		if(e.name ~== "MRGP_UpdateColors"){
			SetUpColors();
			Return;
		}
		if(e.name ~== "MRGP_UpdateBlacklist"){
			SetUpBlacklist();
			Return;
		}
		if(e.name ~== "MRGP_UpdateSounds"){
			SetUpSounds();
			Return;
		}
		if(e.name ~== "MRGP_UpdateRemoveBlood"){
			SetUpBloodRemove();
			Return;
		}
		if(e.name ~== "MRGP_UpdateEffectsData"){
			MR_GoreParticlesStaticHandler Handler = MR_GoreParticlesStaticHandler(StaticEventHandler.Find("MR_GoreParticlesStaticHandler"));
			Handler.OnRegister();
			UpdateEffects();
			UpdateEffectsData();
			Return;
		}
	}
				
	Override Void PlayerEntered(PlayerEvent e)
	{
		SendInterfaceEvent(ConsolePlayer, "MRGP_OpenRecs", 5, 1);
	}
	
	////////////////////////////////////////////////////////////////////////////
	
	Override Void InterfaceProcess(ConsoleEvent e)
	{
		if(e.name ~== "MRGP_OpenRecs")
		{
			if(e.args[1])
			{
				MR_GoreParticlesStaticHandler Handler = MR_GoreParticlesStaticHandler(StaticEventHandler.Find("MR_GoreParticlesStaticHandler"));
				if(Handler.RecSShown)Return;
			}
			
			CheckRecS(e.args[1]);
			if(e.args[1] && Recs.Size()<1)Return;
			
			ShowRecs = !ShowRecs;
			if(RecsAnim<1)RecsAnim = 20;
			if(!ShowRecs)Return;
			if(e.args[0]>0)ShowingRecs = 35*e.args[0];
		}
	}
	
	Ui Array<String> RecS;
	Ui Bool ShowRecs;
	Ui int RecsAnim, ShowingRecs;
	
	Ui Void CheckRecS(bool GameStart = false)
	{
		RecS.Clear();
		String Mod = 'HDOperator';
		if((class<actor>)(Mod))
		{
			if(MRGoreParts_Quake2)RecS.Push("\cc"..StringTable.Localize("$MRGoreParts_BloodSpawnMenu").."\cv/\cg"..StringTable.Localize("$MRGoreParts_Quake2").."\cc 0");
			if(!MRGoreParts_OnlyModsBlood)RecS.Push("\cc"..StringTable.Localize("$MRGoreParts_BloodSpawnMenu").."\cv/\cg"..StringTable.Localize("$MRGoreParts_OnlyModsBlood")..
				"\cc "..1);
			if(MRGoreParts_BloodTypes)RecS.Push("\cc"..StringTable.Localize("$MRGoreParts_BloodSpawnMenu").."\cv/\cg"..StringTable.Localize("$MRGoreParts_BloodTypes").."\cc 0");
			if(MRGoreParts_BlacklistOn)RecS.Push("\cc"..StringTable.Localize("$MRGoreParts_BloodSpawnMenu").."\cv/\cg"..StringTable.Localize("$MRGoreParts_BlacklistOn").."\cc 0");
			if(MRGoreParts_Distance>0)Recs.Push("\cc"..StringTable.Localize("$MRGoreParts_EffectsMenu").."\cv/\cg"..StringTable.Localize("$MRGoreParts_Distance").."\cc 0");
			if(!MRGoreParts_Wounds)RecS.Push("\cc"..StringTable.Localize("$MRGoreParts_WoundsMenu").."\cv/\cg"..StringTable.Localize("$MRGoreParts_Wounds").."\cc 1");
			if(MRGoreParts_CorpseWounds!=1)RecS.Push("\cc"..StringTable.Localize("$MRGoreParts_WoundsMenu").."\cv/\cg"..StringTable.Localize("$MRGoreParts_CorpseWounds")..
				"\cc "..StringTable.Localize("$MRGoreParts_CorpseWounds"..1));
		}
		
		if(GameStart)
		{
			MR_GoreParticlesStaticHandler Handler = MR_GoreParticlesStaticHandler(StaticEventHandler.Find("MR_GoreParticlesStaticHandler"));
			
			Handler.RecSShown = true;
			
			if(RecS.Size()<1)Return;
			Console.Printf(StringTable.Localize("$MR_GoreParticlesUi_RecS"));
			
			For(int i=0;i<Recs.Size();i++)
			{
				Console.Printf(Recs[i]);
			}
			
			Console.Printf(StringTable.Localize("============================"));
		}
	}
	
	Override Void UiTick()
	{
		if(ShowRecs)CheckRecS();
		if(menuactive!=menu.off||!ShowRecs)Return;
				
		if(ShowingRecs>1 && RecsAnim<1)ShowingRecs--;
		if(ShowingRecs==1){ShowingRecs = 0;RecsAnim = 20;ShowRecs = false;Return;}
	}
	
	Override Void RenderOverlay(RenderEvent e)
	{
		if(!ShowRecs && RecsAnim<0)Return;
		
		Let Sb = StatusBar;
		
		Vector2 HUDSca = Sb.GetHUDScale();
		Double HUDScale = ((4/HUDSca.X)/(4/Sb.defaultScale.X));
		
		bool OriginalOffsets = Sb.FullscreenOffsets;
		Sb.FullscreenOffsets = true;
		
		HUDFont MainFont = HUDFont.Create("NewSmallFont");
		
		Double Alph = RecsAnim;
		Alph /= 20;
		
		if(ShowRecS)Alph = 1.-Alph;
		
		int PosY = -NewSmallFont.GetHeight()*.5 * (Recs.Size()-1);
		Sb.DrawString(MainFont, StringTable.Localize("$MR_GoreParticlesUi_RecS"), (0, PosY)*HUDScale, Sb.DI_SCREEN_LEFT_CENTER, Alpha:Alph, Scale:(.5,.5)*HUDScale);
		
		if(RecS.Size()>0)For(int i=0;i<RecS.Size();i++)
		{
			Sb.DrawString(MainFont, RecS[i], (0, PosY+NewSmallFont.GetHeight()*.5*(i+1))*HUDScale, Sb.DI_SCREEN_LEFT_CENTER, Alpha:Alph, Scale:(.5,.5)*HUDScale);
		}
		else 
		{
			String DoneS = StringTable.Localize("$MR_GoreParticlesUi_RecSDone");
			String Sounds = 'MRGP_SoundAddon';
			if(!((class<object>)(Sounds)))DoneS = DoneS.."  "..StringTable.Localize("$MR_GoreParticlesUi_RecSSound");
			Sb.DrawString(MainFont, DoneS, (0, PosY+NewSmallFont.GetHeight()*.5)*HUDScale, Sb.DI_SCREEN_LEFT_CENTER, Font.CR_GREEN, Alph, Scale:(.5,.5)*HUDScale);
		}
		if(RecsAnim>0)RecsAnim--;
		
		Sb.FullscreenOffsets = OriginalOffsets;
	}
}