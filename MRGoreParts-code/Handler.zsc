/*
	Main frame (or smth idk)
	effects spawning, data handling
*/

enum MRGP_BldFlags{
	GPBCF_Glow = 1,
}

Class MRGP_StaticHandler: StaticEventHandler
{
	Ui Bool RecsShown;
	Array<MRGP_Effect> Effects;
	
	
	Override Void OnRegister()
	{
		Effects.Clear();
		
		For(int i=0;i<AllClasses.Size();i++)//Caching particle effects data
		{
			if(AllClasses[i] is 'MRGP_Effect' && !AllClasses[i].IsAbstract())
			{
				Let Clas = MRGP_Effect(New(AllClasses[i].GetClassName()));
				Effects.Push(Clas);
			}
		}
		
		if(!MRGoreParts_Debug)Return;
		
		Console.Printf("\cdAll particles blood effects:");
		For(int i=0;i<Effects.Size();i++)Console.Printf("\cg"..i.."\c- "..Effects[i].GetName());
	}
}

Class MRGP_Handler: EventHandler
{
	Double Dif(Double a, Double b)
	{
		if(a>b)Return a-b;
		
		Return b-a;
	}
	
	Void UpdateSpots(MRGP_Spot a)
	{
		For(int i=0;i<Max(0, Spots.Size()-MRGoreParts_MaxSpots+1);i++)
		{
			if(Spots[i]){Spots[i].Remove();Spots.Delete(i);i--;}
		}
		if(!a)Return;
		Spots.Push(a);
	}
	
	Array<Object> Thinkers;
	
	Array<MRGP_FlyingBlood> Streams;
	Array<MRGP_DeathThinker> Dyings;
	Array<MRGP_CrushedThinker> Crushed;
	Array<int> GibsTime;
	Array<MRGP_Spot> Spots;
	
	//Array<MRGP_DelayedSpawner> Spawners;
	
	Array<Actor> Wounded;
	Array<MRGP_Wound> Wounds;
	
	
	
	Array<MRGP_Effect> Effects, AlwaysEffects;
	
	Void UpdateEffects()
	{
		Let Handler = MRGP_StaticHandler(StaticEventHandler.Find("MRGP_StaticHandler"));
		if(!Handler){Console.printf("Gore-Particles:\cg Error! Static Handler wasn't found.");}
		Effects.Clear();
		
		String TempStr = CVar.FindCVar("MRGoreParts_EffectsList").GetString();
		
		TempStr.Substitute("  ", " ");
		int Akhtung;
		While(TempStr.Length()>0)
		{
			String Num;
			if(TempStr.IndexOf(" ")>-1){Num = TempStr.Left(TempStr.IndexOf(" "));TempStr = TempStr.Mid(TempStr.IndexOf(" ")+1);}
			else {Num = TempStr;TempStr = "";}
			
			if(Num.ToInt()>=0 && Num.ToInt()<Handler.Effects.Size())Effects.Push(Handler.Effects[Num.ToInt()]);
			Akhtung++;
			if(Akhtung>700)Break;
		}
		
		AlwaysEffects.Clear();

		TempStr = CVar.FindCVar("MRGoreParts_AlwaysEffectsList").GetString();
				
		TempStr.Substitute("  ", " ");
		
		Akhtung = 0;
		While(TempStr.Length()>0)
		{
			String Num;
			if(TempStr.IndexOf(" ")>-1){Num = TempStr.Left(TempStr.IndexOf(" "));TempStr = TempStr.Mid(TempStr.IndexOf(" ")+1);}
			else {Num = TempStr;TempStr = "";}
			
			if(Num.ToInt()>=0 && Num.ToInt()<Handler.Effects.Size())AlwaysEffects.Push(Handler.Effects[Num.ToInt()]);
			Akhtung++;
			if(Akhtung>700)Break;
		}
		
		if(!MRGoreParts_Debug)Return;
		
		Console.Printf("\cdRandom effects:");
		For(int i=0;i<Effects.Size();i++)Console.Printf("\cg"..i.."\c- "..Effects[i].GetName().." ("..Effects[i].GetClassName()..")");
		Console.Printf("\cdAlways effects:");
		For(int i=0;i<AlwaysEffects.Size();i++)Console.Printf("\cg"..i.."\c- "..AlwaysEffects[i].GetName().." ("..AlwaysEffects[i].GetClassName()..")");
	}
	
	Void UpdateEffectsData()
	{
		Let Handler = MRGP_StaticHandler(StaticEventHandler.Find("MRGP_StaticHandler"));
		if(!Handler){Console.Printf("Gore-Particles:\cg Error! Static Handler wasn't found.");Return;}
		For(int i=0;i<Handler.Effects.Size();i++){
			if(Handler.Effects[i])Handler.Effects[i].CountParticles(100);
		}
	}
	
	
	Override Void OnRegister()
	{
		SetUpColors();
		SetUpBlacklist();
		SetUpSounds();
		SetUpBloodRemove();
		UpdateEffects();
	}
	
	Map<String, Color> BldCols;//(Vanilla) monsters that supposed to have different blood color
	Map<String, int> BldFlags;
	/*
		MRPRTCOL (MickRomash's gore PaRTiCle COLours) lump stores information
		about blood colours for specific monster classes
		
		Syntax:
		MonsterClassName (R G B)
		
		example:
		HellKnight (10 80 10)
		Cacodemon (30 30 120)
		
		(check filter folder)
	*/
	
	Void SetUpColors()
	{
		BldCols.Clear();
		Array<String> Files;
		int LumpNum = 0;
		While(LumpNum>-1)
		{
			int TempLump = Wads.FindLump("MRPRTCOL", LumpNum+1);
			if(TempLump==-1)Break;
			else {LumpNum = TempLump;Files.Push(Wads.ReadLump(LumpNum));}
		}
		
		For(int i=0;i<Files.Size();i++){
			String Lump = Wads.ReadLump(LumpNum);

			int Akhtung;
			While(Lump.IndexOf("(")>-1)
			{
				String Monster = Lump.Left(Lump.IndexOf(" "));
				Monster.StripLeftRight();
				
				String Cols = Lump.Mid(Lump.IndexOf("(")+1);
				Cols = Cols.Left(Cols.IndexOf("\n"));
				int Vals[3];
				
				For(int i1=0;i1<3;i1++)
				{
					String Temp = Cols.Left(Cols.IndexOf(" "));
					Vals[i1] = Temp.ToInt();
					Cols = Cols.Mid(Cols.IndexOf(" ")+1);
				}

				if((Class<Actor>)(Monster)){
					BldCols.Insert(Monster, Color(Vals[0],Vals[1],Vals[2]));
				
					While(Cols.Indexof("+")>-1){
						int Flags;
						if(Cols.IndexOf("+glow")>-1){
							Flags|=GPBCF_Glow;
						}
						BldFlags.Insert(Monster, Flags);
						Break;
					}
				}
				
				if(Lump.IndexOf("\n")<0)Break;
				Lump = Lump.Mid(Lump.IndexOf("\n")+1);
				
				Akhtung++;
				if(Akhtung>700)Break;
			}
		}
		
		if(MRGoreParts_Debug){
			Console.Printf("\cdBlood color override:");
			Actor Monst;
			Color Col;
			
			Foreach(Monst , Col : BldCols)
			{
				String Str = Monst.." "..Col;
				if(BldFlags.CheckKey(Monst)){
					int Flags = BldFlags.Get(Monst);
					if(Flags&GPBCF_Glow)Str = Str.." glow";
				}
				Console.Printf(Str);
			}
		}
	}
	
	Array< Class <Actor> > BlackList;//List of monsters that shouldn't bleed
	
	Void SetUpBlackList()
	{
		BlackList.Clear();
		String BList = MRGoreParts_BlackList;
		BList.Substitute(" ", "");
		int Akhtung;
		While(BList.Length()>2)
		{
			String Monst;
			if(BList.IndexOf(",")>-1)
			{
				Monst = BList.Left(BList.IndexOf(","));
				BList = BList.Mid(BList.IndexOf(",")+1);
			}
			else 
			{
				Monst = BList;
				Blist = "";
			}
			
			
			Class<Actor> MonstCls = Monst;
			if(MonstCls)BlackList.Push(MonstCls);
			
			Akhtung++;
			if(Akhtung>700)Break;
		}
		
		if(MRGoreParts_Debug){
			Console.Printf("\cdBlacklist:");
			For(int i=0;i<BlackList.Size();i++)Console.Printf("\cg"..BlackList[i].GetClassName());
			Console.Printf("\cd===================");
		}
	}
	
	
	String HitSound, SpraySound, DripSound, GibSound, WoundSound, NoBloodSound;
	
	Void SetUpSounds()//Utilize gore sounds from other mods, if sfx add-on wasn't loaded
	{
		HitSound = "MRGP/Splash";
		DripSound = "MRGP/Drip";
		GibSound = "MRGP/XDeath";
		SpraySound = "MRGP/Spray";
		WoundSound = "MRGP/Wound";
		NoBloodSound = "MRGP/NoBlood";
		
		While(True)
		{
			String Mod;
			
			Mod = 'MRGP_SoundAddon';
			if((Class<Object>)(Mod))Break;//If user loaded my sounds addon, don't use sounds from other mods
			
			
			Array<String> Files;//MRPBldSounds (MRParticles Blood Sounds) lumps. Store aliases of which sounds from the loaded mods to use
			int LumpNum = 0;
			While(LumpNum>-1)
			{
				int TempLump = Wads.FindLump("MRPBldSounds", LumpNum+1);
				if(TempLump==-1)Break;
				else {
					LumpNum = TempLump;
					Files.Push(Wads.ReadLump(LumpNum));
				}
			}
			
			//Console.Printf(Files.Size().." Lumps Found");
			
			For(int i=0;i<Files.Size();i++){//Look inside each lump in case author of the mod wish to replace default aliases
				String File = Files[i];
				File = File.MakeLower();//For easier search
				//Skip comments
				While(File.IndexOf("//")>-1){
					int index = File.IndexOf("//");
					File = File.Left(Index)..File.Mid(File.IndexOf("\n", index));
				}
				
				While(File.IndexOf("/*")>-1){
					int index = File.IndexOf("/*");
					File = File.Left(index)..File.Mid(File.indexOf("*/")+2, index);
				}
				//

				int Cur, Akhtung;

				While(File.IndexOf("mod", Cur+1)>-1){
					if(Akhtung>100)Break;
					Akhtung++;
					
					Mod = File.Mid(File.IndexOf(" ", Cur)+1);//Name of the actor from loaded mod
					Mod = Mod.Left(Mod.IndexOf("\n"));
					Mod.StripRight();

					if((Class<Actor>)(Mod)){
						String Sounds = File.Mid(File.IndexOf("{", Cur)+1);
						Sounds = Sounds.Left(Sounds.IndexOf("}"));//Sound aliases
						
						if(Sounds.IndexOf("hitsound")>-1){
							int index = Sounds.IndexOf("hitsound");
							HitSound = Sounds.Mid(Sounds.IndexOf("(", index)+1);
							HitSound = HitSound.Left(HitSound.IndexOf(")"));
						}
						if(Sounds.IndexOf("dripsound")>-1){
							int index = Sounds.IndexOf("dripsound");
							DripSound = Sounds.Mid(Sounds.IndexOf("(", index)+1);
							DripSound = DripSound.Left(DripSound.IndexOf(")"));
						}
						if(Sounds.IndexOf("gibsound")>-1){
							int index = Sounds.IndexOf("gibsound");
							GibSound = Sounds.Mid(Sounds.IndexOf("(", index)+1);
							GibSound = GibSound.Left(GibSound.IndexOf(")"));
						}
						if(Sounds.IndexOf("spraysound")>-1){
							int index = Sounds.IndexOf("spraysound");
							SpraySound = Sounds.Mid(Sounds.IndexOf("(", index)+1);
							SpraySound = SpraySound.Left(SpraySound.IndexOf(")"));
						}
						if(Sounds.IndexOf("woundsound")>-1){
							int index = Sounds.IndexOf("woundsound");
							WoundSound = Sounds.Mid(Sounds.IndexOf("(", index)+1);
							WoundSound = WoundSound.Left(WoundSound.IndexOf(")"));
						}
						if(Sounds.IndexOf("nobloodsound")>-1){
							int index = Sounds.IndexOf("nobloodsound");
							NoBloodSound = Sounds.Mid(Sounds.IndexOf("(", index)+1);
							NoBloodSound = NoBloodSound.Left(NoBloodSound.IndexOf(")"));
						}
						
					}
					Cur = File.IndexOf("mod", Cur+1);
				}
			}
			Break;
		}
			
		if(MRGoreParts_Debug){
			Console.printf("\n\cgSounds:");
			Console.Printf("\ccHitSound:\cg \""..HitSound.."\"");
			Console.Printf("\ccDripSound:\cg \""..DripSound.."\"");
			Console.Printf("\ccSpraySound:\cg \""..SpraySound.."\"");
			Console.Printf("\ccGibSound:\cg \""..GibSound.."\"");
		}
	}
	
	
	Array<String> RemoveBloods, RemoveBloodTypes;
	String RemoveBloodBase;
	
	Void SetUpBloodRemove()//Caching blood actors that will be hidden/removed
	{
		RemoveBloods.Clear();
		RemoveBloodTypes.Clear();
		
		For(int i=0;i<AllActorClasses.Size();i++)
		{
			String Blud = GetDefaultByType(AllActorClasses[i]).BloodType;
			if(Blud!="Blood" && RemoveBloodTypes.Find(Blud)==RemoveBloodTypes.Size())RemoveBloodTypes.Push(Blud);
			
			Blud = GetDefaultByType(AllActorClasses[i]).BloodType2;
			if(Blud!="BloodSplatter" && RemoveBloodTypes.Find(Blud)==RemoveBloodTypes.Size())RemoveBloodTypes.Push(Blud);
			
			Blud = GetDefaultByType(AllActorClasses[i]).BloodType3;
			if(Blud!="AxeBlood" && RemoveBloodTypes.Find(Blud)==RemoveBloodTypes.Size())RemoveBloodTypes.Push(Blud);
		}
		
		Array<String> Files;//MRPBldRemove (MRParticles Blood to Remove) lumps. Store blood actors names that should be removed
		int LumpNum = 0;
		While(LumpNum>-1)
		{
			int TempLump = Wads.FindLump("MRPBldRemove", LumpNum+1);
			if(TempLump==-1)Break;
			else {
				LumpNum = TempLump;
				Files.Push(Wads.ReadLump(LumpNum));
			}
		}
		
		While(True)
		{
			String Mod;
			
			For(int i=0;i<Files.Size();i++){//Look inside each lump
				String File = Files[i];
				File = File.MakeLower();//For easier search
				//Skip comments
				While(File.IndexOf("//")>-1){
					int index = File.IndexOf("//");
					File = File.Left(Index)..File.Mid(File.IndexOf("\n", index));
				}
				
				While(File.IndexOf("/*")>-1){
					int index = File.IndexOf("/*");
					File = File.Left(index)..File.Mid(File.indexOf("*/")+2, index);
				}
				//
				
				Bool BreakAll;
				int Cur, Akhtung;
				
				While(File.IndexOf("mod", Cur+1)>-1){
					if(Akhtung>100)Break;
					Akhtung++;
					
					Mod = File.Mid(File.IndexOf(" ", Cur)+1);//Name of the actor from loaded mod
					Mod = Mod.Left(Mod.IndexOf("\n"));
					Mod.StripRight();

					if((Class<Actor>)(Mod)){
						BreakAll = true;
						String Removes = File.Mid(File.IndexOf("{", Cur)+1);
						Removes = Removes.Left(Removes.IndexOf("}"));//Blood actors names

						Array<String> Removin;
						int Akhtung1;
						While(Removes.IndexOf("\n")>-1){
							if(Akhtung1>100)Break;
							Akhtung1++;
							String Remove = Removes.Mid(Removes.IndexOf("\n")+2);
							Removes = Remove;
							Remove = Remove.Left(Remove.IndexOf("\n"));
							Remove.StripLeftRight();
							if((Class<Actor>)(Remove))Removin.Push(Remove);
						}
						
						if(Removin.Size()>0){
							RemoveBloodBase = Removin[0];
							Removin.Delete(0);
							For(int i1=0;i1<Removin.Size();i1++){
								RemoveBloods.Push(Removin[i1]);
							}
						}
					}
					Cur = File.IndexOf("mod", Cur+1);
				}
				if(BreakAll)Break;
			}
			Break;
			
			
			
			/*Mod = 'PileOfGibs';//Splatter gore
			if((Class<Actor>)(Mod))
			{
				Break;
			}*/
			
			Break;
		}
		if(MRGoreParts_Debug){
			Console.Printf("\cgBase Blood: "..RemoveBloodBase);
			Console.Printf("\cgBlood Types:");
			For(int i=0;i<RemoveBloodTypes.Size();i++)Console.Printf(i.." "..RemoveBloodTypes[i]);
			Console.Printf("\cgBloods:");
			For(int i=0;i<RemoveBloods.Size();i++)Console.Printf(i.." \""..RemoveBloods[i].."\"");
			Console.Printf("-----------");
		}
	}
	
	Float ViewBob;
	
	Void ThinkersTick()
	{
		For(int i=0;i<Streams.Size()-MRGoreParts_MaxFlyingBlood;i++){
			if(Streams[i])Streams[i].Destroy();
		}
		For(int i=0;i<Streams.Size();i++){
			if(Streams[i])Streams[i].Tick();
		}
		
		For(int i=0;i<GibsTime.Size();i++){//Not a thinker actually, but who cares
			GibsTime[i]++;
			if(GibsTime[i]>(MRGP_GibbingTime/MRGoreParts_Speed)){GibsTime.Delete(i);i--;}
		}
		
		For(int i=0;i<Dyings.Size();i++){
			if(Dyings[i])Dyings[i].Tick();
		}
		
		For(int i=0;i<Crushed.Size();i++){
			if(Crushed[i])Crushed[i].Tick();
		}
		
		For(int i=0;i<Wounds.Size();i++){
			if(Wounds[i])Wounds[i].Tick();
		}
		
		/*For(int i=0;i<Spawners.Size();i++){
			if(Spawners[i])Spawners[i].Tick();
		}*/
	}
	
	Void ThinkersClear()
	{
		For(int i=0;i<Streams.Size();i++){
			if(Streams[i])Streams[i].Destroy();
		}
				
		For(int i=0;i<Dyings.Size();i++){
			if(Dyings[i])Dyings[i].Destroy();
		}
		
		For(int i=0;i<Crushed.Size();i++){
			if(Crushed[i])Crushed[i].Destroy();
		}
		
		For(int i=0;i<Wounds.Size();i++){
			if(Wounds[i])Wounds[i].Destroy();
		}
		
		For(int i=0;i<Thinkers.Size();i++){
			if(Thinkers[i])Thinkers[i].Destroy();
		}
		
		/*For(int i=0;i<Spawners.Size();i++){
			if(Spawners[i])Spawners[i].Destroy();
		}*/
	}
	
	Override Void WorldTick()
	{
		ThinkersTick();

		/////////////////////////////
				
		if(!MRGoreParts_CheckLimit)Return;
		
		Let Plr = Players[ConsolePlayer].Camera;
		if(!Plr)Return;
		
		Vector3 Pos = (0,0, Plr.Player.ViewZ-Plr.Pos.Z);
		Pos.XY += Actor.AngleToVector(Plr.Angle+90, -MRGoreParts_CheckLimitOffset + 1*Abs(Sin(Plr.Pitch)));
		
		Float NewBob = Plr.Player.ViewZ - Plr.Pos.Z - Plr.Player.ViewHeight;
		Float Bob;
		Bob = Actor.DeltaAngle(ViewBob, NewBob);
		
		Pos += (Actor.AngleToVector(Plr.Angle, 4)*Cos(Abs(Plr.Pitch)),Abs(Cos(Plr.Pitch))*2.3 -Sin(Plr.Pitch)*4);
		Pos.XY += Actor.AngleToVector(Plr.Angle, 3.4)*Sin(Plr.Pitch);
		
		
		if(GameTic%4==0)
			Plr.A_SpawnParticle(Color(0,150,0), SPF_FULLBRIGHT, 1, .5, 0, Pos.X,Pos.Y,Pos.Z-Bob -Plr.Vel.Z*1.3,
				Plr.Vel.X,Plr.Vel.Y,Bob +Plr.Vel.Z*1.3, FadeStepf:0);
			
		ViewBob = NewBob;
	}
		
	Bool MRGPartsCheckDraw(Actor mo = Null)
	{
		if(!MRGoreParts_Draw)Return false;
		
		Let Plr = Players[ConsolePlayer].Camera;
		if(!Plr)Return true;
		
		if(!mo)Return true;
		
		
		Return (abs(Actor.DeltaAngle(Plr.Angle, Plr.AngleTo(mo)))<CVar.FindCVar("FOV").GetFloat()||MRGParts.MRDistance2D(Plr, mo)<Plr.Radius*2) && mo.CheckSight(Plr, SF_IGNOREWATERBOUNDARY|SF_SEEPASTBLOCKEVERYTHING|SF_IGNOREVISIBILITY);
	}
	
	Void SpawnNoBlood(Actor mo, Actor inflictor, Double Angle, Actor Source = Null, Bool HDestArmor = false)//Spec. effects for non bleeding actors
	{
		if(MRGoreParts_NoBloodMist)
		{
			Actor Who = mo;
			Double ZOfst = mo.Height*.5;
			if(Inflictor&&MRGParts.MRDistance2D(Inflictor, mo)<mo.Radius*1.5){Who = Inflictor; Angle = Who.AngleTo(mo)+180; ZOfst = 0;}
			
			if(!Who)Return;
			
			Float Bright = CFRandom(.7, 1.4);
			
			Color Col = MRGoreParts_NoBloodMistColor;

			Col = Color(int(Col.R*Bright), int(Col.G*Bright), int(Col.B*Bright));
			
			MRGP_Effect.SpawnEffect('MRGP_Effect_Mist', Who, 0, Angle, Who.Pos.Z/(mo.Pos.Z+mo.Height*.5)*90, Col, Offset:(0,0,ZOfst));
			if(MRGoreParts_NoBloodSndVol>0)Who.A_StartSound(NoBloodSound, CHAN_AUTO, Volume:MRGoreParts_NoBloodSndVol*MRGoreParts_SndVol);
		}
		if(HDestArmor)
		{
			Actor Who = mo;
			Double ZOfst = mo.Height*.5;
			if(Inflictor&& MRGParts.MRDistance2D(Inflictor, mo)<mo.Radius*1.5){Who = Inflictor; Angle = Who.AngleTo(mo)+180; ZOfst = 0;}
			
			if(!Who)Return;
			
			Double Pitch = 0;
			if(Source && PlayerPawn(Source) && Inflictor)Pitch = Inflictor.PitchTo(Source, 5, Source.Player.ViewZ-Source.Pos.Z);
			Pitch = 0;
			
			MRGP_Effect.SpawnEffect('MRGP_Effect_Sparks', Who, 0, Angle, Who.Pos.Z/(mo.Pos.Z+mo.Height*.5)*-90, Offset:(0,0,ZOfst));
		}
	}
	
	Void SpawnWound(Actor Thing=Null, Actor Inflictor=Null, Actor DamageSource=Null, Color Col=Color(0,0,0))
	{
		MRGP_Wound Token;//Wound thinker we're working with
		if(Wounded.Find(Thing)==Wounded.Size())//In case actor hasn't been wounded before, create a new wound thinker
		{
			MRGP_Wound a = New('MRGP_Wound');
			a.Owner = Thing;
			a.PostBeginPlay();
			Token = a;
		}
		else//Otherwise, work with wound thinker linked to this actor
		{
			if(Wounded.Find(Thing)>=Wounds.Size())Return;
			Token = Wounds[Wounded.Find(Thing)];
		}
		
		if(!Token){if(MRGoreParts_Debug)Console.Printf("Couldn't find or create a wound for "..Thing.GetClassName().." at "..Thing.Pos);Return;}
		
		Token.Col = Col;
		
		if(Inflictor != Thing && Inflictor != DamageSource)//Check if it wasn't SH (like bleeding in HDest)
		{
			Bool Replace = true;//Check wounds limit
			For(int i=0;i<MRGoreParts_MaxWounds;i++)
			{
				if(Token.Ages[i]<1)
				{
					//if(MRGoreParts_Debug)Console.Printf("\cdTarget pos:\cc "..Thing.Pos.XY.."\cg inflict pos:\cc "..Inflictor.Pos.XY);
					Vector3 Dif = LevelLocals.Vec3Diff(Inflictor.Pos, Thing.Pos);
	
					Vector3 Home = (0, 0, 0);
					
					Home.Y -= Dif.X*Cos(Thing.Angle-90) + Dif.Y*Sin(Thing.Angle-90);
					Home.X -= Dif.X*Cos(Thing.Angle) + Dif.Y*Sin(Thing.Angle);
					
					Home.XY *= .75;
					
					Home.X *= abs(Cos(Actor.DeltaAngle(Thing.Angle, Thing.AngleTo(Inflictor))));
					Home.Y *= abs(Sin(Actor.DeltaAngle(Thing.Angle, Thing.AngleTo(Inflictor))));

					Home.Z = -Dif.Z+5;
					Home.Z = Min(1, Home.Z/Thing.Height);
					
					if(Home.X>0)Home.X = Min(Home.X, Thing.Radius);
					else Home.X = Max(Home.X, -Thing.Radius);
					
					if(Home.Y>0)Home.Y = Min(Home.Y, Thing.Radius);
					else Home.Y = Max(Home.Y, -Thing.Radius);
					
					Token.Locs[i]=Home;
					Token.Angles[i]=Thing.AngleTo(Inflictor);
					Token.Ages[i]=35*15;
					Replace = false;
					Break;
				}
			}
			if(Replace)//Replace the oldest wound on actor
			{
				//if(MRGoreParts_Debug)Console.Printf("Targ "..Thing.Pos.XY.." inf "..Inflictor.Pos.XY);
				Vector3 Dif = LevelLocals.Vec3Diff(Inflictor.Pos, Thing.Pos);

				Vector3 Home = (0, 0, 0);
				
				Home.Y -= Dif.X*Cos(Thing.Angle-90) + Dif.Y*Sin(Thing.Angle-90);
				Home.X -= Dif.X*Cos(Thing.Angle) + Dif.Y*Sin(Thing.Angle);
				
				Home.XY *= .75;
				
				Home.X *= abs(Cos(Actor.DeltaAngle(Thing.Angle, Thing.AngleTo(Inflictor))));
				Home.Y *= abs(Sin(Actor.DeltaAngle(Thing.Angle, Thing.AngleTo(Inflictor))));

				Home.Z = -Dif.Z+5;
				Home.Z = Min(1, Home.Z/Thing.Height);
				
				if(Home.X>0)Home.X = Min(Home.X, Thing.Radius);
				else Home.X = Max(Home.X, -Thing.Radius);
				
				if(Home.Y>0)Home.Y = Min(Home.Y, Thing.Radius);
				else Home.Y = Max(Home.Y, -Thing.Radius);
				
				Token.Locs[0]=Home;
				Token.Angles[0]=Thing.AngleTo(Inflictor);
				Token.Ages[0]=35*15;
			}
		}
		else//Hideous bleeding
		{
			Array<int> Ages;
			For(int i=0;i<MRGoreParts_MaxWounds;i++)
			{
				if(Token.Ages[i]>0)
				{
					Ages.Push(i);
				}
			}
			
			if(Ages.Size()>0)Token.Ages[Ages[CRandom(0, Ages.Size()-1)]]=1;
			
			else
			{
				Token.Ages[0]=35*15;
				Token.Locs[0]=(Actor.AngleToVector(CRandom(0, 360), Thing.Radius*.3), CFRandom(.15, 1));
			}
		}
	}
		
	////
	//// EVENTS
	////
	
	Override Void WorldThingDamaged(WorldEvent e)
	{
		if(!MRGoreParts_Draw)Return;
		
		if(e.Thing.bIsMonster||e.Thing is 'PlayerPawn'||e.Thing.bCorpse)
		{
			if((e.Thing.bNoBlood && !MRGoreParts_NoBloodMonsters) || (MRGoreParts_BlacklistOn && BlackList.Find(e.Thing.GetClass())!=BlackList.Size()))
			{
				SpawnNoBlood(e.Thing, e.Inflictor, e.DamageAngle);//Special effects for non bleeding actors
				Return;
			}
			
			if(MRGoreParts_BlacklistOn)
				For(int i=0;i<BlackList.Size();i++){
					if(e.Thing is BlackList[i]){SpawnNoBlood(e.Thing, e.Inflictor, e.DamageAngle);Return;}
				}
			
			/*if(MRGoreParts_Debug){
				String Damage = "";
				if(e.DamageFlags&DMG_EXPLOSION)Damage = Damage.."Explosion|";
				if(e.DamageFlags&DMG_USEANGLE)Damage = Damage.."Use_Angle|";
				if(e.DamageFlags&DMG_INFLICTOR_IS_PUFF)Damage = Damage.."IsPuff|";
				Console.Printf("Damage: "..e.DamageType.." Flags: "..Damage);
				if(e.DamageSource)Console.Printf("Source: "..e.DamageSource.GetClassName().." "..e.DamageSource.Pos);
				if(e.Inflictor && e.Inflictor!=e.DamageSource)Console.Printf("Inflictor: "..e.Inflictor.GetClassName().." "..e.Inflictor.Pos);
			}*/
			
			String HDest = 'HDOperator';
			if((Class<Actor>)(HDest))
			{
				String Armour = "HDArmourWorn";
				if(e.DamageType == 'bashing' && e.Thing.CountInv(Armour))
				{
					SpawnNoBlood(e.Thing, e.Inflictor, e.DamageAngle, e.DamageSource, true);
					Return;
				}
				if(e.DamageType != 'piercing' && e.DamageType != 'bleedout')Return;
			}
			
			Float Amount = MRGoreParts_Amount;
				
			Color Col = e.Thing.BloodColor;
			if(MRGoreParts_UseCustomColor)
			{
				Col = MRGoreParts_Color;
			}
			else
			{
				if(e.Thing.BloodColor==0 && e.Thing.BloodTranslation==0)Col = GameInfo.defaultbloodcolor;
				if(BldCols.CheckKey(e.Thing.GetClassName()))Col = BldCols.Get(e.Thing.GetClassName());
			}
			
			int Flags;
			if(BldFlags.CheckKey(e.Thing.GetClassName()))Flags = BldFlags.Get(e.Thing.GetClassName());
			
			int Glow = 0;
			if(Flags&GPBCF_Glow)Glow = SGPF_Glow;
			
			int Fuzzy = 0;
			if(MRGoreParts_FuzzyBlood && (e.Thing.GetRenderStyle() == STYLE_OptFuzzy||e.Thing.GetRenderStyle() == STYLE_Fuzzy))Fuzzy = SGPF_Fuzzy;
			
			
					
			
			if(e.DamageType == 'bleedout')
			{
				Vector3 Pos = (Actor.AngleToVector(e.Thing.Angle + CFRandom(-90, 90), e.Thing.Radius*.7), CRandom(e.Thing.Height*.25, e.Thing.Height*.7));
				
				For(int i=CRandom(0, 2);i<4;i++)
					e.Thing.A_SpawnParticle(Col, Glow?SPF_FULLBRIGHT:0, 20, CFRandom(2, 3), 0, Pos.X,Pos.Y,Pos.Z+.1*i,
						0,0,0, 0,0,-.3);
				MRGP_Effect.SpawnEffect('MRGP_Effect_SimpleSplash', e.Thing, Glow, e.DamageAngle, 0, Col, 1, .6, 1, Pos);
			}
			
			if(e.Inflictor)
			{
				//Console.Printf("\cdHealth: \c-"..e.Thing.Health.." \cgDamage: \c-"..e.Damage);
				//Console.Printf("Damage: "..e.DamageType.." Flags: "..Damage);
				
				if(MRGoreParts_Wounds && !PlayerPawn(e.Thing) && (Wounded.Find(e.Thing)!=Wounded.Size() || Wounded.Size()<MRGoreParts_MaxWounded) && e.DamageType != 'bleedout' && CRandom(0, 10)>4)
				{
					SpawnWound(e.Thing, e.Inflictor, e.DamageSource, Col);
				}
				
				if(e.Inflictor != e.Thing)//Spawn effects
				{
					if(!e.DamageSource)Return;
					Double Pitch = 0;
					if(e.DamageSource && e.DamageSource.Player)Pitch = e.Inflictor.PitchTo(e.DamageSource, 5, e.DamageSource.Player.ViewZ-e.DamageSource.Pos.Z);
					else if(e.DamageSource)Pitch = e.Inflictor.PitchTo(e.DamageSource, 0, e.DamageSource.Height*.9);
					
					Let Spot = e.Inflictor;
					Double VOfst = 0;
					Double DifZ = Dif(Spot.Pos.Z, e.Thing.pos.Z+e.Thing.Height*.5);

					if(MRGParts.MRDistance2D(e.Inflictor, e.Thing)>e.Thing.Radius*1.5||DifZ>e.Thing.Height*.5){Spot = e.Thing;VOfst = e.Thing.Height*.5;}
					
					
					if(Effects.Size()>0)
						Effects[CRandom(0, Effects.Size()-1)].DoParticleEffect(Spot, Fuzzy|Glow, Spot.AngleTo(e.DamageSource), Pitch, Col, offset:(0,0,VOfst));
					For(int i=0;i<AlwaysEffects.Size();i++)
					{
						AlwaysEffects[i].DoParticleEffect(Spot, Fuzzy|Glow, Spot.AngleTo(e.DamageSource), Pitch, Col, Offset:(0,0,VOfst));
					}
					
					if(CRandom(0, 50)>40)e.Inflictor.A_StartSound(DripSound, CHAN_AUTO, Volume:MRGoreParts_SndVol*MRGoreParts_DripSndVol);
					e.Inflictor.A_StartSound(HitSound, CHAN_AUTO, Volume:MRGoreParts_HitSndVol*MRGoreParts_SndVol);


					if(MRGoreParts_DrawFlyingBlood && CFRandom(0, 1)<MRGoreParts_FlyingBloodChance)
					{
						Float Strn = CRandom(4, 6);
						Float Pitch = -CRandom(0, 60);
						Vector3 Vel = (Actor.AngleToVector(e.Inflictor.AngleTo(e.DamageSource)+CRandom(-50, 50), Strn)*Cos(Pitch), -Sin(Pitch)*Strn);
						MRGP_FlyingBlood.Create(e.Inflictor.Pos, Col, Fuzzy|Glow, Scale:4*CFRandom(1, 2), Vel:Vel);
						S_StartSoundAt(e.Inflictor.Pos, SpraySound, CHAN_AUTO, Volume: CFRandom(.2, .3)*MRGoreParts_SndVol*MRGoreParts_SpraySndVol, Pitch: CFrandom(1.1, 1.2));
					}
					//Dripping blood
					if(MRGPartsCheckDraw(e.Inflictor) && MRGoreParts_DripOnImpact){
					Bool Drop = false;
						For(int i=CRandom(0, 3)*Amount;i<6*Amount;i++){
							Float Dist = 1;
							if(e.DamageSource)Dist *= 1+(MRGParts.MRDistance3D(e.Inflictor, e.DamageSource)-80)*.0025;
							Float Size = CFRandom(.8, 1.6)*Dist;
							Float Pitch = e.Inflictor.Pos.Z/e.Thing.Height+CRandom(10, 20);
							if(e.Inflictor is 'BulletPuff' && e.DamageSource)Pitch = e.DamageSource.Pitch+CRandom(10, 20);
							Float Ang = CRandom(175, 185);
							Float Angle = e.Inflictor.AngleTo(e.Thing)+Ang;
							if(e.Inflictor is 'BulletPuff' && e.DamageSource)Angle = e.Inflictor.AngleTo(e.DamageSource)+180+Ang;
							Vector3 Ofst = (Actor.AngleToVector(Angle, 1)*abs(Cos(Pitch)), Sin(Pitch))*Dist;
									
							Ang = CRandom(140, 220)*Dist;
							Angle = e.Inflictor.AngleTo(e.Thing)+Ang;
							if(e.Inflictor is 'BulletPuff' && e.DamageSource)Angle = e.Inflictor.AngleTo(e.DamageSource)+180+Ang;
							Float Bright = MRGoreParts_Brightness*CFrandom(.9, 2);
							Color ColTmp = Color(int(Col.R*Bright), int(Col.G*Bright), int(Col.B*Bright));
							e.Inflictor.A_SpawnParticle(ColTmp, Fuzzy|Glow, CRandom(29, 40), Size*1.3, 0, Ofst.X*2,Ofst.Y*2,5,
									0,0,CFRandom(0, 1), 0,0,-.2, 1, 0, -Size/40);
									
							if(!Drop){//Spot
								Let a = MRGP_Droplet.MRGSpawnDrop(ColTmp, e.inflictor.pos + (Ofst.XY*2, 5), Glow|Fuzzy, RenderStyle:Fuzzy);
								if(a)a.PostBeginPlay();
							}
							Drop = true;
						}
					}
				}
			}
		}
	}
	
	Override Void WorldThingDied(WorldEvent e)
	{
		if(!MRGoreParts_Draw)Return;
		
		if(!e.Thing||!(e.Thing.bIsMonster || e.Thing is 'PlayerPawn')||(e.Thing.bNoBlood && !MRGoreParts_NoBloodMonsters)||
			(BlackList.Find(e.Thing.GetClass())!=BlackList.Size()&&MRGoreParts_BlacklistOn) )Return;
		
		if(MRGoreParts_BlacklistOn)For(int i=0;i<BlackList.Size();i++){if(e.Thing is BlackList[i])Return;}
		
		Color Col = e.Thing.BloodColor;
		if(MRGoreParts_UseCustomColor)
		{
			Col = MRGoreParts_Color;
		}
		else
		{
			if(e.Thing.BloodColor==0 && e.Thing.BloodTranslation==0)Col = GameInfo.defaultbloodcolor;
			if(BldCols.CheckKey(e.Thing.GetClassName()))Col = BldCols.Get(e.Thing.GetClassName());
		}
		
		Float Amount = MRGoreParts_Amount;

		if(e.Thing.FindState("XDeath") && e.Thing.Health<-GetDefaultByType(e.Thing.GetClass()).Health)
		{
			SpawnXDeath(e.Thing, e.Inflictor);
		}
		else if(MRGoreParts_MaxDying>0)
		{
			Let a = New('MRGP_DeathThinker');
			a.Owner = e.Thing;
			a.PostBeginPlay();
			a.Bld = Col;
			a.Artery = Max(0, CRandom(-5, 2));
			
			if(Dyings.Size()>=MRGoreParts_MaxDying)
			{
				Dyings[0].Destroy();
			}
			
			Dyings.Push(a);
		}
	}
	
	Override void WorldThingGround (WorldEvent e)//Crush
	{
		if(!MRGoreParts_Draw)Return;
		
		if(MRGoreParts_Crush<1)Return;
		
		if(!e.Thing)Return;
		if(!e.Thing.bIsMonster&&!e.Thing.bCorpse)Return;
		
		if(MRGoreParts_Debug)Console.Printf(e.Thing.GetClassName().." at "..e.Thing.Pos.." Crushed! (ceiling: "..e.Thing.CeilingZ..")");

		Color Col = e.Thing.BloodColor;
		if(MRGoreParts_UseCustomColor)
		{
			Col = MRGoreParts_Color;
		}
		else
		{
			if(e.Thing.BloodColor==0 && e.Thing.BloodTranslation==0)Col = GameInfo.defaultbloodcolor;
			if(BldCols.CheckKey(e.Thing.GetClassName()))Col = BldCols.Get(e.Thing.GetClassName());
		}
		
		Sector Crusher;
		
		Float Radius = GetDefaultByType(e.Thing.GetClass()).Radius*1.5;
		
		Float Lowest, CeilingZ;
		CeilingZ = e.Thing.CeilingZ;
		
		For(int x = e.Thing.Pos.X-Radius;x<e.Thing.Pos.X+Radius;x+=5)
		{
			For(int Y = e.Thing.Pos.Y-Radius;Y<e.Thing.Pos.Y+Radius;Y+=5)
			{
				Sector TempSect = LevelLocals.PointInSector((X,Y));
				
				if(TempSect.CenterCeiling()!=CeilingZ)Continue;
				
				if(TempSect.PlaneMoving(1)){Crusher = TempSect;Break;}
			}
			if(Crusher)Break;
		}
		
		if(!Crusher){
			SpawnXDeath(e.Thing);
			Return;
		}
		
		if(MRGoreParts_Debug)Console.printf("Got sector");
		
		MRGP_CrushedThinker Nerd = New('MRGP_CrushedThinker');
		
		Nerd.Pos = e.Thing.Pos.XY;
		Nerd.Bld = Col;
		
		int Fuzzy = 0;
		if(MRGoreParts_FuzzyBlood && (e.Thing.GetRenderStyle() == STYLE_OptFuzzy||e.Thing.GetRenderStyle() == STYLE_Fuzzy))Fuzzy = STYLE_Shadow;
		
		Nerd.RenderStyle = Fuzzy;
		Nerd.CurSector = Crusher;
		int PermaDel = 8;
		int Perma;
		For(int i=0;i<360;i+=CRandom(2, 4))//Setting up drops places
		{
			For(float r=CFRandom(1, 4);r<Radius;r*=Max(1.1, CFRandom(1.3, 2)/Min(1, MRGoreParts_Amount))){
				Vector2 Pos = Nerd.Pos+Actor.AngleToVector(i, r);
				
				Sector TempSect = LevelLocals.PointInSector(Pos);
				if(!TempSect)Continue;
				if(TempSect == Nerd.CurSector||TempSect.CenterCeiling()==Nerd.CurSector.CenterCeiling()){
					Nerd.RandX.Push(Pos.X);Nerd.RandY.Push(Pos.Y);
					if(PermaDel>0)PermaDel--;
					else {Perma++; PermaDel = 8;}
				}
			}
		}

		Array<Float> RandX;
		RandX.Copy(Nerd.RandX);
		For(int i=0;i<Perma;i++){
			int Random = CRandom(0, RandX.Size()-1);
			Nerd.Perma.Push(RandX[Random]);
			RandX.Delete(Random);
		}
		
		Nerd.PostBeginPlay();
		
		e.Thing.A_StartSound(GibSound, CHAN_AUTO, Volume: .5*MRGoreParts_SndVol*MRGoreParts_GibSndVol);
		
		if(Crushed.Size()>=MRGoreParts_Crush){
			if(Crushed[0])Crushed[0].DropAll();
		}
				
		Double Size = GetDefaultByType(e.Thing.GetClass()).Height;
		if(Size<GetDefaultByType(e.Thing.GetClass()).Radius)Size = GetDefaultByType(e.Thing.GetClass()).Radius;
		MRGP_Effect.SpawnEffect('MRGP_Effect_Mist', e.Thing, SGPF_NoDist|SGPF_FixAmount|SGPF_NoVel|Fuzzy, CFRandom(0, 360), 0, Col, 1, Size, 2, (0,0,e.Thing.Height*.5), 2, 1/(e.Thing.Mass*.1));
		
		
		For(int i=CRandom(0, 10)*MRGoreParts_Amount;i<50*MRGoreParts_Amount;i++){//Floor splash
			Float Bright = MRGoreParts_Brightness*CFRandom(.5, 1.5);
			Color ColTemp = Color(int(Col.R*Bright),int(Col.G*Bright),int(Col.B*Bright));
			Double Size = GetDefaultByType(e.Thing.GetClass()).Radius*GetDefaultByType(e.Thing.GetClass()).Height;
			Size *= .05;
			Size *= CFRandom(.5, 1.5);
			e.Thing.A_SpawnParticleEx(ColTemp, Texman.CheckForTexture("glpart1"), Fuzzy, SPF_RELATIVE, 130, Size, CRandom(0, 360),
				0,0,1, CFRandom(.6, 1),0,-.005, -CFRandom(.001, .005),0,0, MRGoreParts_Alpha, 0, -(Size/130.));
		}
	}
	
	
	Override Void WorldThingSpawned(WorldEvent e)
	{
		if(!MRGoreParts_OnlyModsBlood&&!MRGoreParts_HideOtherBlood)Return;
		if(!e.Thing)Return;
		
		if(e.Thing is 'Blood'||e.Thing is 'BloodSplatter'||e.Thing is 'AxeBlood'||Actor.GetReplacement("Blood")==e.Thing.GetClass()
			||e.Thing is RemoveBloodBase)
		{
			DoOtherBlood(e.Thing);
			Return;
		}
		
		if(MRGoreParts_BloodTypes)For(int i=0;i<RemoveBloodTypes.Size();i++)
		{
			if(e.Thing is RemoveBloodTypes[i]){DoOtherBlood(e.Thing);Return;}
		}
		
		For(int i=0;i<RemoveBloods.Size();i++)
		{
			if(e.Thing is RemoveBloods[i]){DoOtherBlood(e.Thing);Return;}
		}
		
		//Console.Printf(e.Thing.GetClassName());
	}
		
	Void SpawnBloodDrop(Actor mo, Color Col)//Mainly for hdest
	{
		if(!MRGoreParts_Draw)Return;
		
		Float TempGrav = .3;
		
		For(int i=CRandom(0, 3);i<5;i++)
			mo.A_SpawnParticle(Col, 0, 20, CFRandom(3, 4), 0, CFRandom(-.5,.5),CFRandom(-.5,.5),.1*i, mo.Vel.X,mo.Vel.Y,0, 0,0,TempGrav);
		
		int Delay = 1;
		For(float i=mo.Pos.Z;i>mo.floorZ;i-=TempGrav)
		{
			TempGrav += abs(.3);
			Delay++;
		}
		
		Let a = MRGP_Spot.MRGSpawnSpot(Col, (mo.pos.x+CFRandom(-1, 1), mo.pos.y+CFRandom(-1, 1), mo.floorz+1), 150, Delay, 1, CFRandom(2, 4), CFRandom(.8, .9));
				
		if(a)a.PostBeginPlay();
	}
	
	Void SpawnXDeath(Actor mo, Actor inflictor = Null)
	{
		if(!MRGoreParts_Draw)Return;
		
		mo.A_StartSound(GibSound, CHAN_AUTO, Volume:MRGoreParts_SndVol*MRGoreParts_GibSndVol);
		
		if(GibsTime.Size()>=MRGoreParts_MaxGibing)Return;
		
		int Fuzzy = 0;
		if(MRGoreParts_FuzzyBlood && (mo.GetRenderStyle() == STYLE_OptFuzzy||mo.GetRenderStyle() == STYLE_Fuzzy))Fuzzy = SGPF_Fuzzy;
		
		Color Col = mo.BloodColor;
		if(MRGoreParts_UseCustomColor)
		{
			Col = MRGoreParts_Color;
		}
		else
		{
			if(mo.BloodColor==0 && mo.BloodTranslation==0)Col = GameInfo.defaultbloodcolor;
			if(BldCols.CheckKey(mo.GetClassName()))Col = BldCols.Get(mo.GetClassName());
		}
		
		Let Plr = Players[ConsolePlayer].Camera;
		Bool Draw = true;
		if(Plr)Draw = abs(Actor.deltaangle(Plr.AngleTo(mo), Plr.Angle))<CVar.FindCVar("FOV").GetFloat()||MRGParts.MRDistance2D(Plr, mo)<Plr.Radius*2;
		
		Float Amount = MRGoreParts_Amount;
		
		GibsTime.Push(0);
		
		Float Angle = CRandom(0, 360);
		
		if(Inflictor)Angle = mo.AngleTo(Inflictor)+CRandom(-60, 60);
		
		if(Draw){
			Double Size = mo.Height;
			if(mo.Height<mo.Radius)Size = mo.Radius;
			MRGP_Effect.SpawnEffect('MRGP_Effect_Mist', mo, SGPF_NoDist|SGPF_FixAmount|SGPF_NoVel|Fuzzy, Angle+CRandom(-120, 120), 0, Col, 1, Size, 2, (0,0,mo.Height*.5), 2, 1/(mo.Mass*.1));
		
			For(int i=CRandom(0, 4)*Amount;i<Amount*12;i++)
			{
				if(Effects.Size()>0)
					Effects[CRandom(0, Effects.Size()-1)].DoParticleEffect(mo, Fuzzy, Angle+CRandom(-120, 120), CRandom(-20, 0)*4, Col, 1.1, 4, 1,
						(CRandom(-mo.Radius, mo.Radius)*.5,CRandom(-mo.Radius, mo.Radius)*.5,CRandom(10, mo.Height*.5)), 4, 1/(mo.Mass*.1));
			}
			
			if(MRGoreParts_FloorSplash)For(int i=CRandom(0, 10)*MRGoreParts_Amount;i<40*MRGoreParts_Amount;i++){//Floor splash
				Float Bright = MRGoreParts_Brightness*CFRandom(.5, 1.5);
				Color ColTemp = Color(int(Col.R*Bright),int(Col.G*Bright),int(Col.B*Bright));
				Double Size = GetDefaultByType(mo.GetClass()).Radius*GetDefaultByType(mo.GetClass()).Height;
				Size *= .04;
				Size *= CFRandom(.5, 1.5);
				mo.A_SpawnParticleEx(ColTemp, Texman.CheckForTexture("glpart1"), Fuzzy, SPF_RELATIVE, 100, Size, CRandom(0, 360),
					0,0,1, CFRandom(2, 3),0,-.05, -.03,0,0, MRGoreParts_Alpha, 0, -(Size/100.));
				}
		}
				
		if(MRGoreParts_DrawFlyingBlood){
			int SAmount;
			For(int i=CRandom(0, 3);i<12*MRGoreParts_FlyingBloodChance;i++)
			{
				if(SAmount>5*Amount)Break;
				Float Strn = CRandom(5, 7);
				Float Pitch = -CRandom(40, 90);
				Vector3 Vel = (Actor.AngleToVector(Angle+CRandom(-120, 120), Strn)*Cos(Pitch), -Sin(Pitch)*Strn);
				MRGP_FlyingBlood.Create(mo.Pos, Col, Fuzzy, Scale:4*CFRandom(1, 2), Vel:Vel);
				mo.A_StartSound(SpraySound, CHAN_AUTO, Volume: CFRandom(.1, .3)*MRGoreParts_SndVol*MRGoreParts_SpraySndVol, Pitch: CFrandom(1.1, 1.2));
				SAmount++;
			}
		}
		
	}
	
	Void DoOtherBlood(Actor mo)//Remove or hide other mods gore
	{
		Color Col = Gameinfo.DefaultBloodColor;
		if(MRGoreParts_UseCustomColor)
		{
			Col = MRGoreParts_Color;
		}
		
		String HDBld = 'HDBloodTrailFloor';
		if((Class<Actor>)(HDBld))
		{
			if(mo is HDBld)
			{
				Double Alph = CFRandom(.8, 1);
				mo.A_SpawnParticle(Col, 0, 100, CRandom(2, 3), 0, 0,0,1,
					0,0,0, 0,0,0, Alph, Alph/100.);
				if(MRGoreParts_OnlyModsBlood)mo.Destroy();
				mo.A_SetRenderStyle(mo.Alpha, STYLE_NONE);
				Return;
			}
			
			HDBld = 'BloodSplat';
			String HDBld2 = 'HDMasterBlood';
			if(mo is HDBld2||mo is HDBld)
			{
				String Sheild = 'HDMagicShield';
				if(mo is HDBld2 && mo.Target && mo.Target.CountInv(Sheild)>0 && !mo.bnobouncesound)Return;
				
				if(mo.Target && (mo.Target.BloodTranslation!=0||mo.Target.BloodColor!=0))Col = mo.Target.BloodColor;
				SpawnBloodDrop(mo, Col);
				if(MRGoreParts_OnlyModsBlood)mo.Destroy();
				mo.A_SetRenderStyle(mo.Alpha, STYLE_NONE);
				Return;
			}
		}
		
		if(MRGoreParts_Draw && MRGoreParts_Quake2 && Players[ConsolePlayer].Camera){
			
			int Glow = 0;
			if(MRGoreParts_FullBright)Glow = SPF_FULLBRIGHT;
			For(Int i=CRandom(0, 3);i<9*MRGoreParts_Amount;i++)
			{
				Float Bright = MRGoreParts_Brightness*CFrandom(.8, 1.5);
				mo.A_SpawnParticle(Color(int(col.r*Bright), int(col.g*Bright), int(col.b*Bright)), SPF_RelVel|Glow, 25, CFRandom(1.5, 2.5)*MRGoreParts_Size, mo.AngleTo(Players[ConsolePlayer].Camera),
					Xoff:CFRandom(-1.5, 1.5),CFRandom(-1.5, 1.5),CFRandom(4, 7), .1*MRGoreParts_Speed,0,.5*MRGoreParts_Speed, 0,0, -.05*MRGoreParts_Size*MRGoreParts_Speed);
			}
		}
		
		if(MRGoreParts_OnlyModsBlood){mo.Destroy();Return;}
		
		mo.A_SetRenderStyle(mo.Alpha, STYLE_NONE);
	}
	

	
	Override Void NetworkProcess(ConsoleEvent e)
	{
		if(e.name ~== "MRGP_UpdateEffects"){
			UpdateEffects();
			Return;
		}
		if(e.name ~== "MRGP_UpdateColors"){
			SetUpColors();
			Return;
		}
		if(e.name ~== "MRGP_UpdateBlacklist"){
			SetUpBlacklist();
			Return;
		}
		if(e.name ~== "MRGP_UpdateSounds"){
			SetUpSounds();
			Return;
		}
		if(e.name ~== "MRGP_UpdateRemoveBlood"){
			SetUpBloodRemove();
			Return;
		}
		if(e.name ~== "MRGP_UpdateEffectsData"){
			Let Handler = MRGP_StaticHandler(StaticEventHandler.Find("MRGP_StaticHandler"));
			if(!Handler){Console.Printf("Gore-Particles:\cg Error! Static Handler wasn't found.");}
			Handler.OnRegister();
			UpdateEffects();
			UpdateEffectsData();
			Return;
		}
		
		if(e.name ~== "MRGoreParts_Uninstall"){
			Let Handler = MRGP_StaticHandler(StaticEventHandler.Find("MRGP_StaticHandler"));
			For(int i=0;i<Handler.Effects.Size();i++){
				if(Handler.Effects[i])Handler.Effects[i].Destroy();
			}
			
			ThinkersClear();
			
			Uninstall = true;
			Destroy();
			Return;
		}
	}
	
	Bool Uninstall;
	
	Override Void OnDestroy()
	{
		if(Uninstall)Console.printf(StringTable.Localize("$MRGoreParts_Uninstalled"));
	}
				
	Override Void PlayerEntered(PlayerEvent e)
	{
		SendInterfaceEvent(ConsolePlayer, "MRGP_OpenRecs", 5, 1);
	}
	
	////////////////////////////////////////////////////////////////////////////
	
	Override Void InterfaceProcess(ConsoleEvent e)
	{
		if(e.name ~== "MRGP_OpenRecs")
		{
			if(e.args[1])
			{
				Let Handler = MRGP_StaticHandler(StaticEventHandler.Find("MRGP_StaticHandler"));
				if(!Handler)Return;
				if(Handler.RecSShown)Return;
			}
			
			CheckRecS(e.args[1]);
			if(e.args[1] && Recs.Size()<1)Return;
			
			ShowRecs = !ShowRecs;
			if(RecsAnim<1)RecsAnim = 20;
			if(!ShowRecs)Return;
			if(e.args[0]>0)ShowingRecs = 35*e.args[0];
		}
	}
	
	Ui Array<String> RecS;
	Ui Bool ShowRecs;
	Ui int RecsAnim, ShowingRecs;
	
	Ui Void CheckRecS(bool GameStart = false)
	{
		RecS.Clear();
		String Mod = 'HDOperator';
		if((class<actor>)(Mod))
		{
			if(MRGoreParts_Quake2)RecS.Push("\cc"..StringTable.Localize("$MRGoreParts_BloodSpawnMenu").."\cv/\cg"..StringTable.Localize("$MRGoreParts_Quake2").."\cc 0");
			if(!MRGoreParts_OnlyModsBlood)RecS.Push("\cc"..StringTable.Localize("$MRGoreParts_BloodSpawnMenu").."\cv/\cg"..StringTable.Localize("$MRGoreParts_OnlyModsBlood")..
				"\cc "..1);
			if(MRGoreParts_BloodTypes)RecS.Push("\cc"..StringTable.Localize("$MRGoreParts_BloodSpawnMenu").."\cv/\cg"..StringTable.Localize("$MRGoreParts_BloodTypes").."\cc 0");
			if(MRGoreParts_BlacklistOn)RecS.Push("\cc"..StringTable.Localize("$MRGoreParts_BloodSpawnMenu").."\cv/\cg"..StringTable.Localize("$MRGoreParts_BlacklistOn").."\cc 0");
			if(MRGoreParts_Distance>0)Recs.Push("\cc"..StringTable.Localize("$MRGoreParts_EffectsMenu").."\cv/\cg"..StringTable.Localize("$MRGoreParts_Distance").."\cc 0");
			if(!MRGoreParts_Wounds)RecS.Push("\cc"..StringTable.Localize("$MRGoreParts_WoundsMenu").."\cv/\cg"..StringTable.Localize("$MRGoreParts_Wounds").."\cc 1");
			if(MRGoreParts_CorpseWounds!=1)RecS.Push("\cc"..StringTable.Localize("$MRGoreParts_WoundsMenu").."\cv/\cg"..StringTable.Localize("$MRGoreParts_CorpseWounds")..
				"\cc "..StringTable.Localize("$MRGoreParts_CorpseWounds"..1));
		}
		
		if(GameStart)
		{
			Let Handler = MRGP_StaticHandler(StaticEventHandler.Find("MRGP_StaticHandler"));
			if(!Handler)Return;
			Handler.RecSShown = true;
			
			if(RecS.Size()<1)Return;
			Console.Printf(StringTable.Localize("$MR_GoreParticlesUi_RecS"));
			
			For(int i=0;i<Recs.Size();i++)
			{
				Console.Printf(Recs[i]);
			}
			
			Console.Printf(StringTable.Localize("============================"));
		}
	}
	
	Override Void UiTick()
	{
		if(ShowRecs)CheckRecS();
		if(menuactive!=menu.off||!ShowRecs)Return;
				
		if(ShowingRecs>1 && RecsAnim<1)ShowingRecs--;
		if(ShowingRecs==1){ShowingRecs = 0;RecsAnim = 20;ShowRecs = false;Return;}
	}
	
	Override Void RenderOverlay(RenderEvent e)
	{
		if(!ShowRecs && RecsAnim<0)Return;
		
		Let Sb = StatusBar;
		
		Vector2 HUDSca = Sb.GetHUDScale();
		Double HUDScale = ((4/HUDSca.X)/(4/Sb.defaultScale.X));
		
		bool OriginalOffsets = Sb.FullscreenOffsets;
		Sb.FullscreenOffsets = true;
		
		HUDFont MainFont = HUDFont.Create("NewSmallFont");
		
		Double Alph = RecsAnim;
		Alph /= 20;
		
		if(ShowRecS)Alph = 1.-Alph;
		
		int PosY = -NewSmallFont.GetHeight()*.5 * (Recs.Size()-1);
		Sb.DrawString(MainFont, StringTable.Localize("$MR_GoreParticlesUi_RecS"), (0, PosY)*HUDScale, Sb.DI_SCREEN_LEFT_CENTER, Alpha:Alph, Scale:(.5,.5)*HUDScale);
		
		if(RecS.Size()>0)For(int i=0;i<RecS.Size();i++)
		{
			Sb.DrawString(MainFont, RecS[i], (0, PosY+NewSmallFont.GetHeight()*.5*(i+1))*HUDScale, Sb.DI_SCREEN_LEFT_CENTER, Alpha:Alph, Scale:(.5,.5)*HUDScale);
		}
		else 
		{
			String DoneS = StringTable.Localize("$MR_GoreParticlesUi_RecSDone");
			String Sounds = 'MRGP_SoundAddon';
			if(!((class<object>)(Sounds)))DoneS = DoneS.."  "..StringTable.Localize("$MR_GoreParticlesUi_RecSSound");
			Sb.DrawString(MainFont, DoneS, (0, PosY+NewSmallFont.GetHeight()*.5)*HUDScale, Sb.DI_SCREEN_LEFT_CENTER, Font.CR_GREEN, Alph, Scale:(.5,.5)*HUDScale);
		}
		if(RecsAnim>0)RecsAnim--;
		
		Sb.FullscreenOffsets = OriginalOffsets;
	}
}