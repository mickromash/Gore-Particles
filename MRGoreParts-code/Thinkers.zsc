/*
	My implementation of client-side thinkers
	
	Ticks are called from event handler;
	
	- Why not using visual thinkers?
	- I forgot about them
*/


Class MRGP_Thinker: Object play
{
	MRGP_Handler Handler;
		
	Static Bool MRGPartsCheckDraw(Actor mo=null, float dist=0)
	{
		if(!MRGoreParts_Draw)Return false;
		
		if(!mo)Return True;
		
		Let Plr = Players[ConsolePlayer].Camera;
		if(!Plr)Return false;
		
		
		if(dist!=0 && MRGParts.MRDistance3D(mo, Plr)>Dist)Return false;
		
		if(abs(Actor.DeltaAngle(Plr.AngleTo(mo), Plr.Angle))>CVar.FindCVar("FOV").GetFloat() && MRGParts.MRDistance2D(Plr, mo)>Plr.Radius*2)Return false;
		
		Return Plr.CheckSight(mo, SF_IGNOREWATERBOUNDARY|SF_SEEPASTBLOCKEVERYTHING|SF_IGNOREVISIBILITY);
	}
	
	Bool TickCheck()
	{
		if(!MRGoreParts_Draw){Destroy();Return false;}
		if(Level.isFrozen())Return false;
		Return true;
	}
		
	Virtual Void Tick(){}
	
	Virtual Void PostBeginPlay()
	{
		Handler = MRGP_Handler(EventHandler.Find("MRGP_Handler"));
		if(!Handler){Console.Printf("Gore-Particles:\cg Error! Event Handler wasn't found.");Destroy();Return;}
	}
	
	Void SpawnParticle(Color Col=Color(0,0,0), int Flags=0, int Style=STYLE_None, int Life=1, double Size=1, double Angle=0, Vector3 Pos=(0,0,0), Vector3 Vel=(0,0,0), Vector3 Accel=(0,0,0), Double Alpha=1, Double Fade=0, Double SizeStep=0)
	{
		FSpawnParticleParams p;
		p.Accel = Accel;
		p.Vel = Vel;
		
		p.Pos = Pos;
		
		p.Color1 = Col;
		p.LifeTime = Life;
		p.size = Size;
		p.sizeStep = SizeStep;
		p.startalpha = Alpha;
		p.fadestep = Fade;
		
		int Glow = 0;
		if(MRGoreParts_FullBright)Glow = SPF_FULLBRIGHT;
		p.Flags = Glow|Flags;
		p.Style = Style;
		
		Level.SpawnParticle(p);
	}
}

Class MRGP_DeathThinker: MRGP_Thinker
{
	Color Bld;
	Bool Sos, Artery, Draw;
	Float Mid, RandAngle;
	Actor Owner;
	int Age, Fuzzy;
		
	Override Void PostBeginPlay()
	{
		Super.PostBeginPlay();
		if(!Owner||!Handler)Return;
		Mid = Owner.Height*.5;
		Owner.A_StartSound(Handler.SpraySound, CHAN_AUTO, Volume:MRGoreParts_SndVol*MRGoreParts_SpraySndVol);
		if(MRGoreParts_FuzzyBlood && (Owner.GetRenderStyle() == STYLE_OptFuzzy||Owner.GetRenderStyle() == STYLE_Fuzzy))Fuzzy = SGPF_Fuzzy;
		RandAngle = CRandom(5, 30);
	}
	
	Override Void OnDestroy()
	{
		if(!Handler){Super.OnDestroy();Return;}
		Handler.Dyings.Delete(Handler.Dyings.Find(Self));
		Super.OnDestroy();
	}
	
	Override Void Tick()
	{
		if(Age>60||!Owner){Destroy();Return;}
		if(!TickCheck())Return;
		Age++;
		
		if(Owner.instatesequence(Owner.CurState, Owner.ResolveState("gib")))
		{
			Handler.SpawnXDeath(Owner);//In HDest, actors getting gibbed only after dying
			Destroy();
			Return;
		}
		
		if(Age%2!=0 || !MRGPartsCheckDraw(Owner))Return;
		
		TextureID Sprt = Owner.CurState.GetSpriteTexture(0);
		
		if(!Sprt.IsValid())Return;
			
		Float y = Texman.CheckRealHeight(Sprt)*.9;
		y *= Owner.Scale.Y;

		Float Posy = Y;
		Double Pitch = -90;
		if(Mid<Y)
		{
			Pitch = -(Mid/y)*45;
			//Mid = Pitch;
		}
		
		Double Angle = Owner.Angle;
		if(!MRGoreParts_Voxel && Players[ConsolePlayer].Camera)Angle = Owner.AngleTo(Players[ConsolePlayer].Camera);
		
		if(MRGoreParts_DrawFlyingBlood && CRandom(-500+Artery*200, 70)*(MRGoreParts_FlyingBloodChance*1.5)>Age)
		{
			Float Strn = CRandom(3, 5);
			Vector3 Vel = (Actor.AngleToVector(Angle+CRandom(-RandAngle, RandAngle), Strn)*Max(.1, Cos(Pitch)), -Sin(Pitch)*Strn);
			MRGP_FlyingBlood.Create(Owner.Pos+(0,0,y), Bld, Fuzzy, Scale:4*CFRandom(1, 2), Vel:Vel);
			S_StartSoundAt(Owner.Pos+(0,0,y), Handler.SpraySound, CHAN_AUTO, Volume: CFRandom(.1, .2)*MRGoreParts_SndVol*MRGoreParts_SpraySndVol, Pitch: CFrandom(1.1, 1.2));
		}
		if(Age<CRandom(-40, 60))
		{
			if(Handler.Effects.Size()>0)
				Handler.Effects[CRandom(0, Handler.Effects.Size()-1)].DoParticleEffect(Owner, Fuzzy, Angle+CFRandom(-RandAngle, RandAngle), Pitch, Bld, 1, 1.5, 1, (0,0,Y*.9));
			RandAngle *= .7;
		}
	}
}

Class MRGP_CrushedThinker: MRGP_Thinker
{
	Color Bld;
	Sector CurSector;
	int StartAmount, RenderStyle, Direction, Glow;
	Vector2 Pos;//Thinker position
	Double PosZ, PrevZ, FOV;
	Bool Opened;//Ceiling is higher than floor
	Array<float> RandX, RandY;//Remains drops positions
	Array<Color> Colors;
	Array<Float> Sizes;
	Array<float> Perma;
	
	Bool CheckSight(Vector3 Pos)
	{
		Let Plr = Players[ConsolePlayer].Camera;
		
		if(!Plr.Player)Return true;
		
		Vector3 Dir = (Plr.Pos.XY, Plr.Player.ViewZ);
		
		Vector3 direct = (Actor.AngleToVector(MRGParts.AngleToVector2(Pos.XY, Dir.XY), cos(MRGParts.PitchToVector3(Pos, Dir))), -sin(MRGParts.PitchToVector3(Pos, Dir)));
		Vector3 Dist = Level.Vec3Diff(Pos, Dir);
		
		let tracer = new('MRGP_SightTracer');
		if(!tracer)return false;
		tracer.Trace(Pos, CurSector, direct, Dist.Length(), 0, Line.ML_BLOCKEVERYTHING);
		
		
		if(Tracer.HitPlayer)Return true;
		
		Tracer = new('MRGP_SightTracer');
		
		direct = (Actor.AngleToVector(MRGParts.AngleToVector2(Pos.XY, Dir.XY), 
			cos(MRGParts.PitchToVector3((Pos.XY, CurSector.CenterCeiling()-1), Dir))), -sin(MRGParts.PitchToVector3((Pos.XY, CurSector.CenterCeiling()-1), Dir)));
		Dist = Level.Vec3Diff((Pos.XY, CurSector.CenterCeiling()-1), Dir);
		
		tracer.Trace((Pos.XY, CurSector.CenterCeiling()-1), CurSector, direct, Dist.Length(), 0, Line.ML_BLOCKEVERYTHING);
		
		Return Tracer.HitPlayer;
	}
	
	Bool MRGPartsCheckDraw(float dist, Vector3 Pos)
	{
		if(!MRGoreParts_Draw)Return false;
				
		Let Plr = Players[ConsolePlayer].Camera;
		if(!Plr)Return false;
		
		
		Vector3 Dif = LevelLocals.Vec3Diff(Plr.Pos, Pos);
		
		if(dist!=0 && Dif.Length()>Dist)Return false;
		
		if(abs(Actor.DeltaAngle(MRGParts.AngleToVector2(Plr.Pos.XY, Pos.XY), Plr.Angle))>FOV && Abs(Actor.DeltaAngle(MRGParts.PitchToVector3(Plr.Pos, Pos), Plr.Pitch))>70)Return false;
		
		Return CheckSight(Pos);
	}
	
	Override Void PostBeginPlay()
	{
		Super.PostBeginPlay();
		FOV = CVar.FindCVar("FOV").GetFloat();
		if(!Handler)Return;
		Handler.Crushed.Push(Self);
		
		StartAmount = RandX.Size();
		
		For(int i=0;i<RandX.Size();i++){//Setting up colors and sizes
			Float Bright = MRGoreParts_Brightness*CFrandom(.5, 1.5);
			Color TempCol = Color(int(Bld.R*Bright),int(Bld.G*Bright),int(Bld.B*Bright));
			Colors.Push(TempCol);
			Sizes.Push(MRGoreParts_Size*CFRandom(.4, 2)*3);
		}
	}
	
	Override Void OnDestroy()
	{
		if(!Handler){Super.OnDestroy();Return;}
		Handler.Crushed.Delete(Handler.Crushed.Find(Self));
		Super.OnDestroy();
	}
		
	Override Void Tick(){
		if(!TickCheck())Return;
		
		if(RandX.Size()<1){Destroy();Return;}
		
		if(MRGoreParts_FullBright)Glow = SPF_FULLBRIGHT;
		else Glow = 0;
		
		if(CurSector.CenterFloor()>=CurSector.CenterCeiling()-8){
			
			if(Opened){//When the ceiling reaches the floor, leave some drops on the floor
				Opened = false;

				Float CurPos = CurSector.CenterFloor()+1;
				
				Let Plr = Players[ConsolePlayer].Camera;
				if(!Plr)Return;
				
				Vector3 Dif = Level.Vec3Diff((Pos, CurPos), Plr.Pos);
				Bool InDist = Dif.Length()<500;
				For(int i=0;i<RandX.Size();i++){
					if(CRandom(0, 10)>3)Continue;
										
					if(InDist){
						SpawnParticle(Colors[i], Glow, RenderStyle, 70, Sizes[i], 0, (RandX[i],RandY[i],CurPos), Alpha:MRGoreParts_Alpha, SizeStep:-(Sizes[i]/70.));
					}
					RandX.Delete(i);RandY.Delete(i);Colors.Delete(i);Sizes.Delete(i);
				}
			}
			Return;
		}
		Opened = true;
				
		PosZ = CurSector.CenterCeiling();
		
		
				
		if(Direction<0 && PosZ>=PrevZ){//Ceiling changed direction
			For(int i=CRandom(0, 2);i<5;i++)SpawnDrops(true);//Drops leaves ceiling
		}
		
		else if(Direction>0 && PosZ<=PrevZ){//Ceiling changed direction
			For(int i=CRandom(0, 2);i<4;i++)SpawnDrops(true);//Drops leaves ceiling
		}
		
		For(int i=CRandom(0, 2);i<4;i++)SpawnDrops();//Drops leaves ceiling
		
		if(RandX.Size()<1){Destroy();Return;}
		
		Bool InSight=false;
		
		Float Mid = CurSector.CenterCeiling()-CurSector.CenterFloor();
		if(MRGPartsCheckDraw(1000, (Pos, CurSector.CenterFloor()+Mid*.5)))InSight=true;
		else {
		
			Vector2 LD, LU, RD, RU;
			LD = LU = RD = RU = (RandX[0], RandY[0]);
			
			For(int i=0;i<RandX.Size();i++){
				if(RandX[i]<=LD.X && RandY[i]<=LD.Y)LD = (RandX[i], RandY[i]);
				if(RandX[i]<=LU.X && RandY[i]>=LU.Y)LU = (RandX[i], RandY[i]);
				if(RandX[i]>=RD.X && RandY[i]<=RD.Y)RD = (RandX[i], RandY[i]);
				if(RandX[i]>=RU.X && RandY[i]>=RU.Y)RU = (RandX[i], RandY[i]);
			}

			While(True){//Sight check on the furthest spots
				if(MRGPartsCheckDraw(1000, (LD, CurSector.CenterFloor()+Mid*.5))){InSight=true;Break;}
				if(LD!=LU && MRGPartsCheckDraw(1000, (LU, CurSector.CenterFloor()+Mid*.5))){InSight=true;Break;}
				if(RD!=LU && RD!=LD && MRGPartsCheckDraw(1000, (RD, CurSector.CenterFloor()+Mid*.5))){InSight=true;Break;}
				if(RU!=RD && RU!=LD && RU!=LU && MRGPartsCheckDraw(1000, (RU, CurSector.CenterFloor()+Mid*.5))){InSight=true;Break;}
				Break;
			}
		}
		
		if(InSight)SpawnStatic();//Drops on the ceiling
		
		if(PosZ<PrevZ)Direction = -1;
		else if(PosZ>PrevZ)Direction = 1;
		else Direction = 0;
		
		PrevZ = PosZ;//Interpolation
	}
	
	Void SpawnDrops(Bool NoRandom=false, int Num=-1)
	{
		if(!NoRandom && RandX.Size()<CRandom(0, StartAmount))Return;
		if(RandX.Size()<1)Return;
		
		int Rand = Num;
		if(Rand==-1)Rand = CRandom(0, RandX.Size()-1);
		
		if(Perma.Size()>0 && Perma.Find(RandX[Rand])!=Perma.Size()){
			if(CRandom(0, 10)>3){//Permanent drop leaves ceiling
				Let a = MRGP_Droplet.MRGSpawnDrop(Colors[Rand], (RandX[Rand], RandY[Rand], CurSector.CenterCeiling()-3), Scale: Sizes[Rand]*.5, RenderStyle:RenderStyle);
			}
			else {//Permanent drop stays on ceiling
				Color TempCol = Color(int(Colors[Rand].R*.9), int(Colors[Rand].G*.9), int(Colors[Rand].B*.9));
				Let a = MRGP_Spot.MRGSpawnSpot(TempCol, (RandX[Rand], RandY[Rand], CurSector.CenterCeiling()), MRGoreParts_SpotsTime*35, 0, 0, Sizes[Rand], 1, 2, RenderStyle:RenderStyle);
			}
			Perma.Delete(Perma.Find(RandX[Rand]));
		}
		else {
			S_StartSoundAt((RandX[Rand], RandY[Rand], CurSector.CenterFloor()), Handler.DripSound, CHAN_AUTO, Volume:CFRandom(.1, .2)*MRGoreParts_SndVol*MRGoreParts_DripSndVol, attenuation:ATTN_STATIC);
			SpawnParticle(Colors[Rand], Glow, RenderStyle, 50, Sizes[Rand], 0, (RandX[Rand],RandY[Rand],PosZ), Accel:(0,0,-CFRandom(.3, .8)), Alpha:MRGoreParts_Alpha, SizeStep:-(Sizes[Rand]/50.));
		}
		RandX.Delete(Rand);RandY.Delete(Rand);Colors.Delete(Rand);Sizes.Delete(Rand);
	}
	
	Void SpawnStatic()
	{
		Float Mid = CurSector.CenterCeiling()-CurSector.CenterFloor();
		Float CurPos = PrevZ;
		Float VelZ = PosZ-PrevZ;
		if(PosZ<PrevZ)CurPos = PosZ;
		if(PosZ==PrevZ){CurPos = PosZ;VelZ=0;}
		
		For(int i=0;i<RandX.Size();i++){
			SpawnParticle(Colors[i], SPF_REPLACE|Glow, RenderStyle, 1, Sizes[i], 0, (RandX[i],RandY[i],CurPos-1), (0,0,VelZ), Alpha:MRGoreParts_Alpha);
		}
	}
	
	Void DropAll()
	{
		Destroy();
		if(!Opened)Return;
		
		For(int i=0;i<RandX.Size();i++){
			SpawnDrops(true, i);
		}
	}
}

Class MRGP_Spot: VisualThinker
{
	int Surface;//0 - Wall, 1 - Floor, 2 - Ceiling
	Bool FromCeiling;//In case spot placed on a wall of a sector that is originates from the ciling
	int Life, Age, Delay, Sliding;
	Double Height, StartScale, StartAlpha;
	Sector LinkedSector;
	Bool NoAlpha, PlaySound, InArray, Drip, Fallin, OnLiquid;
	
	Override Void Tick()
	{
		Super.Tick();

		if(Delay>0 && Age>=Delay && Scale.X==0){
			Scale = (1, 1)*StartScale;
			if(PlaySound){
				Let Handler = MRGP_Handler(EventHandler.Find("MRGP_Handler"));
				if(Handler)S_StartSoundAt(Pos, Handler.DripSound, CHAN_AUTO, Volume:MRGoreParts_SndVol*MRGoreParts_DripSndVol);
			}
		}
				
		if(Age+20>=Life){
			if(Age>=Life){
				if(InArray){
					Let Handler = MRGP_Handler(EventHandler.Find("MRGP_Handler"));
					if(Handler)Handler.Spots.Delete(Handler.Spots.Find(Self));
				}
				Destroy();
				Return;
			}
			
			if(NoAlpha&&!OnLiquid){
				Double Scal = StartScale*((Life-Age)/20.);
				
				Scale = (1, 1)*Scal;
			}
			else {
				Double Alph = StartAlpha*((Life-Age)/20.);
				
				Alpha = Alph;
			}
		}
		
		if(Drip && !Fallin && CRandom(0, 100)==1)Fallin = true;
		
		if(Fallin){
			Vel.Z -= CFRandom(.2, .4);
			if(CurSector && Pos.Z<=CurSector.CenterFloor()){
				Pos.Z = CurSector.CenterFloor()+2;
				Vel.Z = 0;
				Surface = 1;
				Fallin = false;
			}
		}
		
		else Switch(Surface){
			Case 0://Wall
				if(LinkedSector){
					if(FromCeiling){
						Pos.Z = LinkedSector.CenterCeiling()+Height;//Move spot with the wall
						if(Sliding>0){//Sliding down
							Height -= CFRandom(.005, .01);
							if(Height<0)Fallin = true;//If reached the bottom, fall down
							Sliding--;
						}
					}
					
					else {
						Pos.Z = LinkedSector.CenterFloor()-Height;//Move spot with the wall
						if(Sliding>0){//Sliding down
							Height += CFRandom(.005, .01);
							Sliding--;
						}
					}
				}
				else Pos.Z -= CFRandom(.005, .01);
				Break;
			Case 1://Floor
				if(CurSector)Pos.Z = CurSector.CenterFloor()+2;
				Break;
			Case 2://Ceiling
				if(CurSector)Pos.Z = CurSector.CenterCeiling()-2;
				Break;
		}
		
		Age++;
	}
	
	Override Void PostBeginPlay()
	{
		if(!Texture)Switch(MRGOreParts_SpotsStyle){
			Case 2:
				Texture = Texman.CheckForTexture("GParMst1");//Smooth
				StartScale *= .01;
				//Offset = (32, 32)*-StartScale;
				Break;
			Case 1:
				Texture = Texman.CheckForTexture("glpart2");//Round
				StartScale *= .004;
				//Offset = (64, 64)*-StartScale;
				Break;
			Case 0:
				Texture = Texman.CheckForTexture("GParMst2");//Square
				//Offset = (.5, .5)*-StartScale;
				Break;
		}
		
		if(Delay>0)Scale = (0, 0);
		else Scale = (1, 1)*StartScale;
		Alpha = StartAlpha;
		
		NoAlpha = MRGoreParts_LowAlpha;
		
		Fallin = false;
		
		Sliding = CRandom(1, 10)*35;
		
		if(CurSector && Surface>0){
			if(CheckLiquid())Return;
		}
		
		Let Handler = MRGP_Handler(EventHandler.Find("MRGP_Handler"));
		if(Handler)Handler.Thinkers.Push(Self);
	}
	
	Bool CheckLiquid()
	{
		Let Pic = CurSector.GetTexture(Surface-1);

		if(!Pic.IsValid())Return false;
		
		String PicName = Texman.GetName(Pic);
		PicName.MakeUpper();
		
		//Stolen from UGibs
		Static Const String Waters [] = {"SEWER", "WATER", "WATR", "WTR", "SLIME0", "SLM", "SLUGDE", "SLUD", "LAVA", "LAV", "SLM", "TAR", "NUKE",
			"NUKAGE", "GOOP", "MAGMA", "FLATHUH", "FLTFLWW", "FLTWAWA", "X_0", "OICYWA", "BLOOD", "BLOD", "BLD"};
		
		Bool IsLiquid = false;
		
		For(int i=0;i<Waters.Size();i++){
			if(PicName.IndexOf(Waters[i])>-1){
				IsLiquid = true;Break;
			}
		}
		
		if(!IsLiquid)Return false;
		
		if(CurSector.DamageAmount>0){//Hot floor, evaporate leaving stim 
			MRGParts.MRSpawnParticle(SColor, MRSPF_SMOKE, 0, 35, StartScale*3, 0, Pos, (CFRandom(-.1, .1), CFRandom(-.1, .1), CFRandom(.3, .6)), (0,0,0), .9, .05, .25);
			S_StartSoundAt(Pos, "Gibs/AcidBurn", CHAN_AUTO, Volume:CFRandom(.02, .04), pitch:CFRandom(1.7, 1.9));
			Destroy();
			Return true;
		}
		
		OnLiquid = true;
		Remove();
		
		Return false;
	}
	
	Static MRGP_Spot MRGSpawnSpot(Color Col, Vector3 Pos, int Life = 1, int Delay = 0, Bool PlaySound = 0, Double Scale = 1, Double Alpha = 1,
		int Surface = 1, Double Height = 0, Bool FromCeiling = 0, Sector LinkedSector = Null, int RenderStyle = STYLE_NORMAL)
	{
		if(!MRGoreParts_FloorSpots)Return Null;
		
		Let Spot = MRGP_Spot(level.SpawnVisualThinker('MRGP_Spot'));
		if(!Spot)Return Null;
		
		Spot.Pos = Pos;
		Spot.SColor = Col;
		Spot.Life = Life;
		Spot.Delay = Delay;
		Spot.Surface = Surface;
		if(Surface<1)Spot.Flags |= SPF_NO_XY_BILLBOARD;
		//if(MRGoreParts_FullBright)Spot.Flags |= SPF_FULLBRIGHT;
		Spot.Height = Height;
		Spot.FromCeiling = FromCeiling;
		Spot.LinkedSector = LinkedSector;
		Spot.PlaySound = PlaySound;
		Spot.StartScale = Scale;
		Spot.StartAlpha = Alpha;
		Spot.SetRenderStyle(RenderStyle);
		Spot.CurSector = LevelLocals.PointInSector(Pos.XY);
		
		if(Spot.CurSector){//Check if spot is placed on the skybox
			Switch(Surface){
					TextureId Pic;
				Case 0:
					if(LinkedSector){
						Pic = LinkedSector.GetTexture(FromCeiling);
					}
					else Break;
				Case 1:
				Case 2:
					if(!Pic)Pic = Spot.CurSector.GetTexture(Surface-1);
					String PicName = Texman.GetName(Pic);
					if(PicName ~== "F_SKY1"||
						PicName ~== "F_SKY"||
						PicName ~== "F_SKY001"){
							Spot.Destroy();
							Return Null;
					}
			}
		}
		
		Return Spot;
	}
	
	Void Remove()
	{
		if(Age>Life-20)Destroy();
		else Age = Life-20;
	}
	
	Override Void OnDestroy()
	{
		Let Handler = MRGP_Handler(EventHandler.Find("MRGP_Handler"));
		if(Handler && Handler.Thinkers.Find(Self)<Handler.Thinkers.Size())Handler.Thinkers.Delete(Handler.Thinkers.Find(Self));
		Super.OnDestroy();
	}
}

Class MRGP_Droplet: VisualThinker
{
	Double Diff(Double a, Double b)
	{
		if(a>b)Return a-b;
		
		Return b-a;
	}
	
	Double StartScale;
	int RenderStyle;
	Vector3 Accel;
	
	Override Void OnDestroy()
	{
		Let Handler = MRGP_Handler(EventHandler.Find("MRGP_Handler"));
		if(Handler && Handler.Thinkers.Find(Self)<Handler.Thinkers.Size())Handler.Thinkers.Delete(Handler.Thinkers.Find(Self));
		Super.OnDestroy();
	}
	
	Override Void PostBeginPlay()
	{
		if(!Texture)Switch(gl_particles_style){
			Case 2:
				Texture = Texman.CheckForTexture("GParMst1");//Smooth
				Scale *= .01;
				//Offset = (32, 32)*-StartScale;
				Break;
			Case 1:
				Texture = Texman.CheckForTexture("glpart2");//Round
				Scale *= .004;
				//Offset = (64, 64)*-StartScale;
				Break;
			Default:
				Texture = Texman.CheckForTexture("GParMst2");//Square
				//Offset = (.5, .5)*-StartScale;
				Break;
		}
		
		Let Handler = MRGP_Handler(EventHandler.Find("MRGP_Handler"));
		if(Handler)Handler.Thinkers.Push(Self);
		Scale *= StartScale;
	}
	
	Override Void Tick()
	{
		Super.Tick();
		
		if(Level.IsFrozen())Return;
		
		Scale *= .95;
		if(Scale.X<.0001){Destroy();Return;}
				
		Vector3 dir = Vel;
		
		Bool Landed = false;
		int HitSurface;
		
		let tracer = new('MRGP_SightTracer');

		tracer.CheckSurface = true;
		tracer.Trace(Pos, Level.PointInSector(Pos.XY), dir, 5, 0, Line.ML_BLOCKEVERYTHING, true);
		
		if(Tracer.HitType!=TRACE_HitNone){
			HitSurface(Tracer.HitType, Tracer.HitLine, Tracer.HitPos);
			Landed = true;
		}
				
		if(CurSector){
			if(abs(Diff(Pos.Z, CurSector.CenterFloor()))<=abs(Vel.Z)){HitSurface(TRACE_HitFloor, HitPos: (Pos.XY, CurSector.CenterFloor()));Landed = true;HitSurface = 1;}
			if(abs(Diff(Pos.Z, CurSector.CenterCeiling()))<=abs(Vel.Z)){HitSurface(TRACE_HitCeiling, HitPos: (Pos.XY, CurSector.CenterCeiling()));Landed = true;HitSurface = 2;}
		}
		
		if(Landed){Splash(Tracer.HitLine, HitSurface);Destroy();Return;}
		
		Pos += Vel;
		
		Vel += Accel;
	}
	
	Virtual Void HitSurface(int HitType, Line HitLine=Null, Vector3 HitPos=(0,0,0))
	{
		if(!MRGoreParts_FloorSpots)Return;
		int Ofst = -1;
		int Glow = 0;
		Let Handler = MRGP_Handler(EventHandler.Find("MRGP_Handler"));
		if(!Handler)Return;

		Double Vol = Max(0, Min(1, Vel.Length()/9));
		S_StartSoundAt(Pos, Handler.DripSound, CHAN_AUTO, Volume:Vol*MRGoreParts_SndVol*MRGoreParts_DripSndVol, attenuation:ATTN_STATIC);
		
		if(MRGoreParts_FullBright)Glow = SPF_FULLBRIGHT;
		Switch(HitType){
		
			Case TRACE_HitWall:
				{
				Double Angle = VectorAngle(HitLine.Delta.X, HitLine.Delta.Y);
								
				
				Sector BackSector = HitLine.BackSector;
				if(BackSector==CurSector)BackSector = HitLine.FrontSector;
				
				Bool Plane;
				if(BackSector && HitPos.Z > BackSector.CenterCeiling())Plane = true;
					Color TempCol = Color(int(SColor.R*.9), int(SColor.G*.9), int(SColor.B*.9));
					
					
					Let PPos = HitPos;
					
					PPos += Level.Vec2Diff(PPos.XY, Pos.XY).Unit()*1.5;
					
					Double Height;
					if(BackSector){
						if(Plane)Height = PPos.Z-BackSector.CenterCeiling();
						else Height = BackSector.CenterFloor()-PPos.Z;
					}
					
					Let a = MRGP_Spot.MRGSpawnSpot(TempCol, PPos, MRGoreParts_SpotsTime*35, 0, 0, StartScale, 1, 0, Height, Plane, BackSector);
					
					if(a){
						a.SetRenderStyle(RenderStyle);
						a.Flags = Glow;
						a.InArray = true;
						Handler.UpdateSpots(a);
					}
				}
				Break;
				
			Case TRACE_HitFloor:
				Ofst = 1;
			Case TRACE_HitCeiling:
				{
					Color TempCol = Color(int(SColor.R*.9), int(SColor.G*.9), int(SColor.B*.9));
					
					Let a = MRGP_Spot.MRGSpawnSpot(TempCol, HitPos + (0,0, Ofst), MRGoreParts_SpotsTime*35, 0, 0, StartScale, 1, (Ofst>0?1:2));
					
					if(a){
						a.SetRenderStyle(RenderStyle);
						a.Flags = Glow;
						a.InArray = true;
						//a.Drip = true;
						Handler.UpdateSpots(a);
					}
				}
				Break;
		}
	}
	
	Void Splash(Line HitWall = Null, int Surface = 0)
	{
		int Glow = 0;
		if(MRGoreParts_FullBright)Glow = SPF_FULLBRIGHT;
		
		Vector3 Dir = (Actor.AngleToVector(VectorAngle(Vel.X, Vel.Y), cos(MRGParts.VectorPitch(Vel))), -sin(MRGParts.VectorPitch(Vel)));
		Double Strngt = Min(4, Vel.Length()/5);
		
		Double Pitch[2];
		Switch(Surface)
		{
			Case 1://Floor
				Pitch[0] = 0;
				Pitch[1] = 90;
				Break;
			Case 2://Ceiling
				Pitch[0] = -90;
				Pitch[1] = 0;
		}
		
		Double WallAng[2];
		WallAng[0] = 0;WallAng[1] = 360;
		Double Ang = VectorAngle(Vel.X, Vel.Y);
				
		if(HitWall){
			WallAng[0] = VectorAngle(HitWall.Delta.X, HitWall.Delta.Y);
			WallAng[1] = WallAng[0]+180;
			if(WallAng[1]>360)WallAng[1] = WallAng[1]%360;
			
			if(Clamp(Ang, WallAng[0], WallAng[1])!=Ang){
				Double Temp = WallAng[0];
				WallAng[0] = WallAng[1];
				WallAng[1] = Temp;
			}
			
			Switch(Surface)
			{
				Default://Wall
					Pitch[0] = -45;
					Pitch[1] = 45;
					Break;
				Case 1://Floor
					Pitch[0] = 0;
					Pitch[1] = 90;
					Break;
				Case 2://Ceiling
					Pitch[0] = -90;
					Pitch[1] = 0;
			}
		}
		
		
		For(int i=0;i<4;i++){
			Double Pit = CRandom(Pitch[0], Pitch[1]);
			Vector3 TempDir = (Actor.AngleToVector(CRandom(WallAng[0], WallAng[1]), Strngt)*Cos(Pit), Strngt*Sin(Pit));
			
			Float Bright = CFRandom(1, 1.5);
			Color Col = Color(int(SColor.R*Bright), int(SColor.G*Bright), int(SColor.B*Bright));
			Float Life = CRandom(7, 10);
			Float Scal = StartScale*CFRandom(.2, .4);
			MRGParts.MRSpawnParticle(Col, Glow, RenderStyle, Life, Scal, 0, Pos,
				TempDir*CFRandom(.8, 1.1), (0,0,-.4), SizeStep:-(Scal/Life));
		}
	}
	
	Static MRGP_Droplet MRGSpawnDrop(Color Col, Vector3 Pos, int Flags=0, Vector3 Vel = (0,0,0), Vector3 Accel = (0,0,-.5), Double Scale = 3, int RenderStyle = STYLE_NORMAL)
	{
		Let Drop = MRGP_Droplet(level.SpawnVisualThinker('MRGP_Droplet'));
		if(!Drop)Return Null;
		
		Drop.Pos = Pos;
		Drop.Vel = Vel;
		Drop.Accel = Accel;
		Drop.SColor = Col;
		if(Flags&GPBCF_Glow)Drop.Flags |= SPF_FULLBRIGHT;
		Drop.StartScale = Scale;
		Drop.SetRenderStyle(RenderStyle);
		Drop.RenderStyle = RenderStyle;
		
		Return Drop;
	}
}