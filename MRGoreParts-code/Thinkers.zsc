/*
	My implementation of client-side thinkers
	
	Ticks are called from event handler;
	
	- Why not using visual thinkers?
	- I forgot about them
*/


Class MR_GoreParticlesThinker: Object play
{
	MR_GoreParticlesHandler Handler;
	
	Static Bool MRGPartsCheckDraw(Actor mo=null, float dist=0)
	{
		if(!MRGoreParts_Draw)Return false;
		
		if(!mo)Return True;
		
		Let Plr = Players[ConsolePlayer].Camera;
		if(!Plr)Return false;
		
		
		if(dist!=0 && Plr.Distance3D(mo)>Dist)Return false;
		
		if(abs(Actor.DeltaAngle(Plr.AngleTo(mo), Plr.Angle))>CVar.FindCVar("FOV").GetFloat() && Plr.Distance2D(mo)>Plr.Radius*2)Return false;
		
		Return Plr.CheckSight(mo, SF_IGNOREWATERBOUNDARY|SF_SEEPASTBLOCKEVERYTHING|SF_IGNOREVISIBILITY);
	}
	
	Bool TickCheck()
	{
		if(!MRGoreParts_Draw){Destroy();Return false;}
		if(Level.isFrozen())Return false;
		Return true;
	}
		
	Virtual Void Tick(){}
	
	Virtual Void PostBeginPlay()
	{
		Handler = MR_GoreParticlesHandler(EventHandler.Find("MR_GoreParticlesHandler"));
		if(!Handler){Console.Printf("Gore-Particles:\cg Error! Event Handler wasn't found.");Destroy();Return;}
	}
	
	Void SpawnParticle(Color Col=Color(0,0,0), int Flags=0, int Style=STYLE_None, int Life=1, double Size=1, double Angle=0, Vector3 Pos=(0,0,0), Vector3 Vel=(0,0,0), Vector3 Accel=(0,0,0), Double Alpha=1, Double Fade=0, Double SizeStep=0)
	{
		FSpawnParticleParams p;
		p.Accel = Accel;
		p.Vel = Vel;
		
		p.Pos = Pos;
		
		p.Color1 = Col;
		p.LifeTime = Life;
		p.size = Size;
		p.sizeStep = SizeStep;
		p.startalpha = Alpha;
		p.fadestep = Fade;
		
		int Glow = 0;
		if(MRGoreParts_FullBright)Glow = SPF_FULLBRIGHT;
		p.Flags = Glow|Flags;
		p.Style = Style;
		
		Level.SpawnParticle(p);
	}
}

Class MR_GoreParticlesDelayedSpawner: MR_GoreParticlesThinker//You'll never guess what mod it originates from
{
	Color Col;
	Double Alpha, Size, Fade, Resize;
	Vector3 Ofst, Vely, Accel,  Pos;
	int Delay, Life, Fuzzy,  Age;
	Bool PlaySound;
	
	Override Void PostBeginPlay()
	{
		Super.PostBeginPlay();
		if(!Handler)Return;
		if(Handler)Handler.Spawners.Push(Self);
	}
	
	Override VOid OnDestroy()
	{
		if(!Handler)Return;
		Handler.Spawners.Delete(Handler.Spawners.Find(Self));
		Super.OnDestroy();
	}
	
	Override Void Tick()
	{
		if(!TickCheck())Return;
		
		Sector CurSector = Level.PointInSector(Pos.XY);
		if(CurSector)Pos.Z = CurSector.CenterFloor();
		
		if((Delay>-1&&Age>=Delay)||Delay<0)
		{
			SpawnParticle(Col, 0, Fuzzy, Life, Size, 0, Pos+Ofst, Vely, Accel, Alpha, Fade, Resize);
			if(PlaySound)S_StartSoundAt(Pos+Ofst, Handler.DripSound, CHAN_AUTO, Volume:MRGoreParts_SndVol*MRGoreParts_DripSndVol);
			Destroy();
			Return;
		}
		
		Age++;
		
		Return;
	}
}

Class MR_GoreParticlesDeathThinker: MR_GoreParticlesThinker
{
	Color Bld;
	Bool Sos, Artery, Draw;
	Float Mid;
	Actor Owner;
	int Age, Fuzzy;
		
	Override Void PostBeginPlay()
	{
		Super.PostBeginPlay();
		if(!Owner||!Handler)Return;
		Mid = Owner.Height*.5;
		Owner.A_StartSound(Handler.SpraySound, CHAN_AUTO, Volume:MRGoreParts_SndVol*MRGoreParts_SpraySndVol);
		if(MRGoreParts_FuzzyBlood && (Owner.GetRenderStyle() == STYLE_OptFuzzy||Owner.GetRenderStyle() == STYLE_Fuzzy))Fuzzy = SGPF_Fuzzy;
	}
	
	Override Void OnDestroy()
	{
		if(!Handler)Return;
		Handler.Dyings.Delete(Handler.Dyings.Find(Self));
		Super.OnDestroy();
	}
	
	Override Void Tick()
	{
		if(Age>60||!Owner){Destroy();Return;}
		if(!TickCheck())Return;
		Age++;
		
		if(Owner.instatesequence(Owner.CurState, Owner.ResolveState("gib")))
		{
			Handler.SpawnXDeath(Owner);//In HDest, actors getting gibbed only after dying
			Destroy();
			Return;
		}
		
		if(Age%2!=0 || !MRGPartsCheckDraw(Owner))Return;
		
		TextureID Sprt = Owner.CurState.GetSpriteTexture(0);
		
		if(Sprt.IsValid())
		{
			
			Float y = Texman.CheckRealHeight(Sprt)*.9;
			y *= Owner.Scale.Y;

			Float Posy = Y;
			Double Pitch = -90;
			if(Mid<Y)
			{
				Pitch = -(Mid/y)*45;
				//Mid = Pitch;
			}
			
			Double Angle = Owner.Angle;
			if(!MRGoreParts_Voxel && Players[ConsolePlayer].Camera)Angle = Owner.AngleTo(Players[ConsolePlayer].Camera);
			
			if(MRGoreParts_DrawFlyingBlood && CRandom(-500+Artery*200, 70)*(MRGoreParts_FlyingBloodChance*1.5)>Age)
			{
				Float Strn = CRandom(3, 5);
				Vector3 Vel = (Actor.AngleToVector(Angle+CRandom(-50, 50), Strn)*Max(.1, Cos(Pitch)), -Sin(Pitch)*Strn);
				MR_GoreParticlesFlyingBlood.Create(Owner.Pos+(0,0,y), Bld, Fuzzy, Scale:4*CFRandom(1, 2), Vel:Vel);
				S_StartSoundAt(Owner.Pos+(0,0,y), Handler.SpraySound, CHAN_AUTO, Volume: CFRandom(.1, .2)*MRGoreParts_SndVol*MRGoreParts_SpraySndVol, Pitch: CFrandom(1.1, 1.2));
			}
			if(Age<CRandom(-40, 60))
			{
				if(Handler.Effects.Size()>0)
					Handler.Effects[CRandom(0, Handler.Effects.Size()-1)].DoParticleEffect(Owner, Fuzzy, Angle, Pitch, Bld, 1, 1.5, 1, (0,0,Y*.9));
			}
		}
	}
}

Class MR_GoreParticlesCrushedThinker: MR_GoreParticlesThinker
{
	Color Bld;
	Sector CurSector;
	int StartAmount, RenderStyle;
	Vector2 Pos;//Thinker position
	Double PosZ, PrevZ, FOV;
	Bool Opened;//Ceiling is higher than floor
	Array<float> RandX, RandY;//Remains drops positions
	Array<Color> Colors;
	Array<Float> Sizes;
	
	Static Double AngleToVector2(Vector2 Pos, Vector2 Dir)
	{
		Vector2 Dif = Levellocals.Vec2Diff(Pos, Dir);
		
		Return VectorAngle(Dif.X, Dif.Y);
	}
	
	Static Double PitchToVector3(Vector3 Pos, Vector3 Dir)
	{
		Vector3 Dif = Levellocals.Vec3Diff(Pos, Dir);
		
		Return -atan2(Dif.Z, Dif.XY.Length());
	}
	
	Bool CheckSight(Vector3 Pos)
	{
		Let Plr = Players[ConsolePlayer].Camera;
		
		if(!Plr.Player)Return true;
		
		Vector3 Dir = (Plr.Pos.XY, Plr.Player.ViewZ);
		
		Vector3 direct = (Actor.AngleToVector(AngleToVector2(Pos.XY, Dir.XY), cos(PitchToVector3(Pos, Dir))), -sin(PitchToVector3(Pos, Dir)));
		Vector3 Dist = Level.Vec3Diff(Pos, Dir);
		
		let tracer = new('MR_GoreParticlesSightTracer');
		if(!tracer)return false;
		tracer.Trace(Pos, CurSector, direct, Dist.Length(), 0, Line.ML_BLOCKEVERYTHING);
		
		
		if(Tracer.HitPlayer)Return true;
		
		Tracer = new('MR_GoreParticlesSightTracer');
		
		direct = (Actor.AngleToVector(AngleToVector2(Pos.XY, Dir.XY), 
			cos(PitchToVector3((Pos.XY, CurSector.CenterCeiling()-1), Dir))), -sin(PitchToVector3((Pos.XY, CurSector.CenterCeiling()-1), Dir)));
		Dist = Level.Vec3Diff((Pos.XY, CurSector.CenterCeiling()-1), Dir);
		
		tracer.Trace((Pos.XY, CurSector.CenterCeiling()-1), CurSector, direct, Dist.Length(), 0, Line.ML_BLOCKEVERYTHING);
		
		Return Tracer.HitPlayer;
	}
	
	Bool MRGPartsCheckDraw(float dist, Vector3 Pos)
	{
		if(!MRGoreParts_Draw)Return false;
				
		Let Plr = Players[ConsolePlayer].Camera;
		if(!Plr)Return false;
		
		
		Vector3 Dif = LevelLocals.Vec3Diff(Plr.Pos, Pos);
		
		if(dist!=0 && Dif.Length()>Dist)Return false;
		
		if(abs(Actor.DeltaAngle(AngleToVector2(Plr.Pos.XY, Pos.XY), Plr.Angle))>FOV && Abs(Actor.DeltaAngle(PitchToVector3(Plr.Pos, Pos), Plr.Pitch))>70)Return false;
		
		Return CheckSight(Pos);
	}
	
	Override Void PostBeginPlay()
	{
		Super.PostBeginPlay();
		FOV = CVar.FindCVar("FOV").GetFloat();
		if(!Handler)Return;
		Handler.Crushed.Push(Self);
		
		StartAmount = RandX.Size();
		
		For(int i=0;i<RandX.Size();i++){//Setting up colors and sizes
			Float Bright = MRGoreParts_Brightness*CFrandom(.5, 1.5);
			Color TempCol = Color(int(Bld.R*Bright),int(Bld.G*Bright),int(Bld.B*Bright));
			Colors.Push(TempCol);
			Sizes.Push(MRGoreParts_Size*CFRandom(.4, 2)*3);
		}
	}
	
	Override Void OnDestroy()
	{
		if(!Handler)Return;
		Handler.Crushed.Delete(Handler.Crushed.Find(Self));
		Super.OnDestroy();
	}
		
	Override Void Tick(){
		if(!TickCheck())Return;
		
		if(RandX.Size()<1){Destroy();Return;}
		
		if(CurSector.CenterFloor()>=CurSector.CenterCeiling()-8){
			
			if(Opened){//When the ceiling reaches the floor, leave some drops on the floor
				Opened = false;

				Float CurPos = CurSector.CenterFloor()+1;
				
				Let Plr = Players[ConsolePlayer].Camera;
				if(!Plr)Return;
				
				Vector3 Dif = Level.Vec3Diff((Pos, CurPos), Plr.Pos);
				Bool InDist = Dif.Length()<500;
				For(int i=0;i<RandX.Size();i++){
					if(CRandom(0, 10)>3)Continue;
										
					if(InDist){
						SpawnParticle(Colors[i], 0, RenderStyle, 70, Sizes[i], 0, (RandX[i],RandY[i],CurPos), Alpha:MRGoreParts_Alpha, SizeStep:-(Sizes[i]/70.));
					}
					RandX.Delete(i);RandY.Delete(i);Colors.Delete(i);Sizes.Delete(i);
				}
			}
			Return;
		}
		Opened = true;
		
		PosZ = CurSector.CenterCeiling();
		For(int i=0;i<CRandom(2, 4);i++)SpawnDrops();//Drops leaves ceiling
		SpawnStatic();//Drops on the ceiling
		
		PrevZ = PosZ;//Interpolation
	}
	
	Void SpawnDrops()
	{
		if(RandX.Size()<CRandom(0, StartAmount))Return;
		
		int Rand = CRandom(0, RandX.Size()-1);
		
		S_StartSoundAt((RandX[Rand], RandY[Rand], CurSector.CenterFloor()), Handler.DripSound, CHAN_AUTO, Volume:CFRandom(.1, .2)*MRGoreParts_SndVol*MRGoreParts_DripSndVol, attenuation:ATTN_STATIC);
		SpawnParticle(Colors[Rand], 0, RenderStyle, 50, Sizes[Rand], 0, (RandX[Rand],RandY[Rand],PosZ), Accel:(0,0,-CFRandom(.3, .8)), Alpha:MRGoreParts_Alpha, SizeStep:-(Sizes[Rand]/50.));
		
		RandX.Delete(Rand);RandY.Delete(Rand);Colors.Delete(Rand);Sizes.Delete(Rand);
	}
	
	Void SpawnStatic()
	{
		Float Mid = CurSector.CenterCeiling()-CurSector.CenterFloor();
		Float CurPos = PrevZ;
		Float VelZ = PosZ-PrevZ;
		if(PosZ<PrevZ)CurPos = PosZ;
		if(PosZ==PrevZ){CurPos = PosZ;VelZ=0;}
		
		For(int i=0;i<RandX.Size();i++){
			if(!MRGPartsCheckDraw(1000, (RandX[i], RandY[i], CurSector.CenterFloor()+Mid*.5)))Continue;
			SpawnParticle(Colors[i], 0, RenderStyle, 1, Sizes[i], 0, (RandX[i],RandY[i],CurPos-1), (0,0,VelZ), Alpha:MRGoreParts_Alpha);
		}
	}
	
	Void DropAll()
	{
		Destroy();
		if(!Opened)Return;
		
		For(int i=0;i<RandX.Size();i++){
			SpawnDrops();
		}
	}
}