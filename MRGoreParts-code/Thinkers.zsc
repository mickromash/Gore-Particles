/*
	My implementation of client-side thinkers
	
	Ticks are called from event handler;
	For wounds thinker, check Wounds.zsc
*/


Class MR_GoreParticlesThinker: Object play
{
	MR_GoreParticlesHandler Handler;
	
	Static Bool MRGPartsCheckDraw(Actor mo=null, float dist=0)
	{
		if(!MRGoreParts_Draw)Return false;
		
		if(!mo)Return True;
		
		Let Plr = Players[ConsolePlayer].Camera;
		if(!Plr)Return false;
		
		
		if(dist!=0 && Plr.Distance3D(mo)>Dist)Return false;
		
		if(abs(Actor.DeltaAngle(Plr.AngleTo(mo), Plr.Angle))>CVar.FindCVar("FOV").GetFloat())Return false;
		
		Return Plr.CheckSight(mo);
	}
		
	Virtual Void Tick(){if(Level.IsFrozen())Return;}
	Virtual Void PostBeginPlay()
	{
		Handler = MR_GoreParticlesHandler(EventHandler.Find("MR_GoreParticlesHandler"));
	}
}

Class MR_GoreParticlesDeathThinker: MR_GoreParticlesThinker
{
	Color Bld;
	Bool Sos, Artery, Draw;
	Float Mid, Fov;
	Actor Owner;
	int Age, Fuzzy;
		
	Override Void PostBeginPlay()
	{
		Super.PostBeginPlay();
		if(!Owner)Return;
		Mid = Owner.Height*.5;
		Owner.A_StartSound(Handler.SpraySound, CHAN_AUTO);
		Fov = CVar.FindCVar("FOV").GetFloat();
		if(MRGoreParts_FuzzyBlood && (Owner.GetRenderStyle() == STYLE_OptFuzzy||Owner.GetRenderStyle() == STYLE_Fuzzy))Fuzzy = SGPF_Fuzzy;
	}
	
	Override Void OnDestroy()
	{
		if(!Handler)Return;
		Handler.Dyings.Delete(Handler.Dyings.Find(Self));
		Super.OnDestroy();
	}
	
	Override Void Tick()
	{
		if(Age>60||!Owner){Destroy();Return;}
		Super.Tick();
		Age++;
		
		if(Owner.instatesequence(Owner.CurState, Owner.ResolveState("gib")))
		{
			Handler.SpawnXDeath(Owner);
			Destroy();
			Return;
		}
		
		if(Age%2!=0 || !MRGPartsCheckDraw(Owner))Return;
		
		TextureID Sprt = Owner.CurState.GetSpriteTexture(0);
		
		if(Sprt.IsValid())
		{
			
			Float y = Texman.CheckRealHeight(Sprt)*.9;
			y *= Owner.Scale.Y;

			Float Posy = Y;
			Double Pitch = -90;
			if(Mid<Y)
			{
				Pitch = -(Mid/y)*45;
				//Mid = Pitch;
			}
			
			Double Angle = Owner.Angle;
			if(!MRGoreParts_Voxel && Players[ConsolePlayer].Camera)Angle = Owner.AngleTo(Players[ConsolePlayer].Camera);
			
			if(MRGoreParts_DrawFlyingBlood && CRandom(-500+Artery*200, 70)>Age)
			{
				Float Strn = CRandom(3, 5);
				Vector3 Vel = (Actor.AngleToVector(Angle+CRandom(-50, 50), Strn)*Max(.1, Cos(Pitch)), -Sin(Pitch)*Strn);
				MR_GoreParticlesFlyingBlood.Create(Owner.Pos+(0,0,y), Bld, Fuzzy, Scale:4*CFRandom(1, 2), Vel:Vel);
				S_StartSoundAt(Owner.Pos+(0,0,y), Handler.SpraySound, CHAN_AUTO, Volume: CFRandom(.1, .2), Pitch: CFrandom(1.1, 1.2));
			}
			if(Age<CRandom(-40, 60))
			{
				if(Handler.Effects.Size()>0)
					Handler.Effects[CRandom(0, Handler.Effects.Size()-1)].DoParticleEffect(Owner, Fuzzy, Angle, Pitch, Bld, 1, 1.5, 1, (0,0,Y*.9));
			}
		}
	}
}

Class MR_GoreParticlesCrashedThinker: MR_GoreParticlesThinker
{
	Color Bld;
	Sector CurSector;
	int StartAmount, RenderStyle;
	Vector2 Pos;
	Double Radius, PosZ, PrevZ, FOV;
	Bool Opened;
	Array<float> RandX, RandY;
	Array<Color> Colors;
	Array<Float> Sizes;
	
	Static Double AngleToVector2(Vector2 Pos, Vector2 Dir)
	{
		Vector2 Dif = Levellocals.Vec2Diff(Pos, Dir);
		
		Return VectorAngle(Dif.X, Dif.Y);
	}
	
	Static Double PitchToVector3(Vector3 Pos, Vector3 Dir)
	{
		Vector3 Dif = Levellocals.Vec3Diff(Pos, Dir);
		
		Return -atan2(Dif.Z, Dif.XY.Length());
	}
	
	Bool CheckSight(Vector3 Pos)
	{
		Let Plr = Players[ConsolePlayer].Camera;
		
		if(!Plr.Player)Return true;
		
		Vector3 Dir = (Plr.Pos.XY, Plr.Player.ViewZ);
		
		Vector3 direct = (Actor.AngleToVector(AngleToVector2(Pos.XY, Dir.XY), cos(PitchToVector3(Pos, Dir))), -sin(PitchToVector3(Pos, Dir)));
		Vector3 Dist = Level.Vec3Diff(Pos, Dir);
		
		let tracer = new('MR_GoreParticlesSightTracer');
		if(!tracer)return false;
		tracer.Trace(Pos, CurSector, direct, Dist.Length(), 0, Line.ML_BLOCKEVERYTHING);
		
		
		if(Tracer.HitPlayer)Return true;
		
		Tracer = new('MR_GoreParticlesSightTracer');
		
		direct = (Actor.AngleToVector(AngleToVector2(Pos.XY, Dir.XY), 
			cos(PitchToVector3((Pos.XY, CurSector.CenterCeiling()-1), Dir))), -sin(PitchToVector3((Pos.XY, CurSector.CenterCeiling()-1), Dir)));
		Dist = Level.Vec3Diff((Pos.XY, CurSector.CenterCeiling()-1), Dir);
		
		tracer.Trace((Pos.XY, CurSector.CenterCeiling()-1), CurSector, direct, Dist.Length(), 0, Line.ML_BLOCKEVERYTHING);
		
		Return Tracer.HitPlayer;
	}
	
	Bool MRGPartsCheckDraw(float dist, Vector3 Pos)
	{
		if(!MRGoreParts_Draw)Return false;
				
		Let Plr = Players[ConsolePlayer].Camera;
		if(!Plr)Return false;
		
		
		Vector3 Dif = LevelLocals.Vec3Diff(Plr.Pos, Pos);
		
		if(dist!=0 && Dif.Length()>Dist)Return false;
		
		if(abs(Actor.DeltaAngle(AngleToVector2(Plr.Pos.XY, Pos.XY), Plr.Angle))>FOV && Abs(Actor.DeltaAngle(PitchToVector3(Plr.Pos, Pos), Plr.Pitch))>70)Return false;
		
		Return CheckSight(Pos);
	}
	
	Override Void PostBeginPlay()
	{
		Super.PostBeginPlay();
		FOV = CVar.FindCVar("FOV").GetFloat();
		Handler.Crashed.Push(Self);
				
		For(int i=0;i<360;i+=CRandom(2, 4))
		{
			For(float r=CFRandom(1, 4);r<Radius;r*=CFRandom(1.3, 2)/Min(1, MRGoreParts_Amount)){
				Vector2 Pos = Pos+Actor.AngleToVector(i, r);
				
				Sector TempSect = LevelLocals.PointInSector(Pos);
				
				if(TempSect == CurSector||TempSect.CenterCeiling()==CurSector.CenterCeiling()){
					RandX.Push(Pos.X);RandY.Push(Pos.Y);
				}
			}
		}
		
		StartAmount = RandX.Size();
		
		For(int i=0;i<RandX.Size();i++){
			Float Bright = MRGoreParts_Brightness*CFrandom(.5, 1.5);
			Color TempCol = Color(int(Bld.R*Bright),int(Bld.G*Bright),int(Bld.B*Bright));
			Colors.Push(TempCol);
			Sizes.Push(MRGoreParts_Size*CFRandom(.4, 2)*3);
		}
	}
	
	Override Void OnDestroy()
	{
		if(!Handler)Return;
		Handler.Crashed.Delete(Handler.Crashed.Find(Self));
		Super.OnDestroy();
	}
		
	Override Void Tick(){
		Super.Tick();
		if(RandX.Size()<1){Destroy();Return;}
		
		if(CurSector.CenterFloor()>=CurSector.CenterCeiling()){
			
			if(Opened){
				Opened = false;
				//Array<int> Delete;
				Float CurPos = CurSector.CenterFloor()+1;
				
				Let Plr = Players[ConsolePlayer].Camera;
				if(!Plr)Return;
				
				Vector3 Dif = Level.Vec3Diff((Pos, CurPos), Plr.Pos);
				Bool InDist = Dif.Length()<500;
				For(int i=0;i<RandX.Size();i++){
					if(CRandom(0, 10)>3)Continue;
										
					if(InDist){
						FSpawnParticleParams p;
						p.Accel = (0,0,0);
						p.Vel = (0,0,0);
						
						p.Pos = (RandX[i],RandY[i],CurPos);
						
						p.Color1 = Colors[i];
						p.LifeTime = 50;
						p.size = Sizes[i];
						p.sizeStep = -(Sizes[i]/50.);
						p.startalpha = 1;
						p.fadestep = 0;
						
						int Glow = 0;
						if(MRGoreParts_FullBright)Glow = SPF_FULLBRIGHT;
						p.Flags = Glow;
						p.Style = RenderStyle;
						
						Level.SpawnParticle(p);
					}
					RandX.Delete(i);RandY.Delete(i);Colors.Delete(i);Sizes.Delete(i);
				}
			}
			Return;
		}
		Opened = true;
		
		PosZ = CurSector.CenterCeiling();
		For(int i=0;i<CRandom(2, 4);i++)SpawnDrops();
		SpawnStatic();
		
		PrevZ = PosZ;
	}
	
	Void SpawnDrops()
	{
		if(RandX.Size()<CRandom(0, StartAmount))Return;
		
		FSpawnParticleParams p;
		p.Accel = (0,0,-CFRandom(.3, .8));
		p.Vel = (0,0,0);
		
		p.Pos = (0,0,PosZ);
		
		int Rand = CRandom(0, RandX.Size()-1);
		
		Float Mid = CurSector.CenterCeiling()-CurSector.CenterFloor();
		
		S_StartSoundAt((RandX[Rand], RandY[Rand], CurSector.CenterFloor()), Handler.DripSound, CHAN_AUTO, Volume:CFRandom(.1, .2), attenuation:ATTN_STATIC);
		
		//if(!MRGPartsCheckDraw(1000, (RandX[Rand], RandY[Rand], CurSector.CenterFloor()+Mid*.5)))Return;
		
		p.Pos.XY = (RandX[Rand], RandY[Rand]);
		
		p.Color1 = Colors[Rand];
		p.LifeTime = 50;
		p.size = Sizes[Rand];
		p.sizeStep = -(p.size/50.);
		p.startalpha = 1;
		p.fadestep = 0;
		
		int Glow = 0;
		if(MRGoreParts_FullBright)Glow = SPF_FULLBRIGHT;
		p.Flags = Glow;
		p.Style = RenderStyle;
		
		Level.SpawnParticle(p);
		
		RandX.Delete(Rand);RandY.Delete(Rand);Colors.Delete(Rand);Sizes.Delete(Rand);
	}
	
	Void SpawnStatic()
	{
		Float Mid = CurSector.CenterCeiling()-CurSector.CenterFloor();
		Float CurPos = PrevZ;
		Float VelZ = PosZ-PrevZ;
		if(PosZ<PrevZ)CurPos = PosZ;
		if(PosZ==PrevZ){CurPos = PosZ;VelZ=0;}
		For(int i=0;i<RandX.Size();i++){
		
			if(!MRGPartsCheckDraw(1000, (RandX[i], RandY[i], CurSector.CenterFloor()+Mid*.5)))Continue;
		
			FSpawnParticleParams p;
			p.Accel = (0,0,0);
			p.Vel = (0,0,VelZ);
			
			p.Pos = (RandX[i],RandY[i],CurPos-1);
			
			p.Color1 = Colors[i];
			p.LifeTime = 1;
			p.size = Sizes[i];
			p.sizeStep = 0;
			p.startalpha = 1;
			p.fadestep = 0;
			
			int Glow = 0;
			if(MRGoreParts_FullBright)Glow = SPF_FULLBRIGHT;
			p.Flags = Glow;
			p.Style = RenderStyle;
			
			Level.SpawnParticle(p);
		}
	}
}