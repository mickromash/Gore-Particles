/*
	My implementation of client-side thinkers
	
	Ticks are called from event handler;
	
	- Why not using visual thinkers?
	- I forgot about them
*/


Class MR_GoreParticlesThinker: Object play
{
	MR_GoreParticlesHandler Handler;
		
	Static Bool MRGPartsCheckDraw(Actor mo=null, float dist=0)
	{
		if(!MRGoreParts_Draw)Return false;
		
		if(!mo)Return True;
		
		Let Plr = Players[ConsolePlayer].Camera;
		if(!Plr)Return false;
		
		
		if(dist!=0 && MRGParts.MRDistance3D(mo, Plr)>Dist)Return false;
		
		if(abs(Actor.DeltaAngle(Plr.AngleTo(mo), Plr.Angle))>CVar.FindCVar("FOV").GetFloat() && MRGParts.MRDistance2D(Plr, mo)>Plr.Radius*2)Return false;
		
		Return Plr.CheckSight(mo, SF_IGNOREWATERBOUNDARY|SF_SEEPASTBLOCKEVERYTHING|SF_IGNOREVISIBILITY);
	}
	
	Bool TickCheck()
	{
		if(!MRGoreParts_Draw){Destroy();Return false;}
		if(Level.isFrozen())Return false;
		Return true;
	}
		
	Virtual Void Tick(){}
	
	Virtual Void PostBeginPlay()
	{
		Handler = MR_GoreParticlesHandler(EventHandler.Find("MR_GoreParticlesHandler"));
		if(!Handler){Console.Printf("Gore-Particles:\cg Error! Event Handler wasn't found.");Destroy();Return;}
	}
	
	Void SpawnParticle(Color Col=Color(0,0,0), int Flags=0, int Style=STYLE_None, int Life=1, double Size=1, double Angle=0, Vector3 Pos=(0,0,0), Vector3 Vel=(0,0,0), Vector3 Accel=(0,0,0), Double Alpha=1, Double Fade=0, Double SizeStep=0)
	{
		FSpawnParticleParams p;
		p.Accel = Accel;
		p.Vel = Vel;
		
		p.Pos = Pos;
		
		p.Color1 = Col;
		p.LifeTime = Life;
		p.size = Size;
		p.sizeStep = SizeStep;
		p.startalpha = Alpha;
		p.fadestep = Fade;
		
		int Glow = 0;
		if(MRGoreParts_FullBright)Glow = SPF_FULLBRIGHT;
		p.Flags = Glow|Flags;
		p.Style = Style;
		
		Level.SpawnParticle(p);
	}
}

Class MR_GoreParticlesDeathThinker: MR_GoreParticlesThinker
{
	Color Bld;
	Bool Sos, Artery, Draw;
	Float Mid;
	Actor Owner;
	int Age, Fuzzy;
		
	Override Void PostBeginPlay()
	{
		Super.PostBeginPlay();
		if(!Owner||!Handler)Return;
		Mid = Owner.Height*.5;
		Owner.A_StartSound(Handler.SpraySound, CHAN_AUTO, Volume:MRGoreParts_SndVol*MRGoreParts_SpraySndVol);
		if(MRGoreParts_FuzzyBlood && (Owner.GetRenderStyle() == STYLE_OptFuzzy||Owner.GetRenderStyle() == STYLE_Fuzzy))Fuzzy = SGPF_Fuzzy;
	}
	
	Override Void OnDestroy()
	{
		if(!Handler)Return;
		Handler.Dyings.Delete(Handler.Dyings.Find(Self));
		Super.OnDestroy();
	}
	
	Override Void Tick()
	{
		if(Age>60||!Owner){Destroy();Return;}
		if(!TickCheck())Return;
		Age++;
		
		if(Owner.instatesequence(Owner.CurState, Owner.ResolveState("gib")))
		{
			Handler.SpawnXDeath(Owner);//In HDest, actors getting gibbed only after dying
			Destroy();
			Return;
		}
		
		if(Age%2!=0 || !MRGPartsCheckDraw(Owner))Return;
		
		TextureID Sprt = Owner.CurState.GetSpriteTexture(0);
		
		if(Sprt.IsValid())
		{
			
			Float y = Texman.CheckRealHeight(Sprt)*.9;
			y *= Owner.Scale.Y;

			Float Posy = Y;
			Double Pitch = -90;
			if(Mid<Y)
			{
				Pitch = -(Mid/y)*45;
				//Mid = Pitch;
			}
			
			Double Angle = Owner.Angle;
			if(!MRGoreParts_Voxel && Players[ConsolePlayer].Camera)Angle = Owner.AngleTo(Players[ConsolePlayer].Camera);
			
			if(MRGoreParts_DrawFlyingBlood && CRandom(-500+Artery*200, 70)*(MRGoreParts_FlyingBloodChance*1.5)>Age)
			{
				Float Strn = CRandom(3, 5);
				Vector3 Vel = (Actor.AngleToVector(Angle+CRandom(-50, 50), Strn)*Max(.1, Cos(Pitch)), -Sin(Pitch)*Strn);
				MR_GoreParticlesFlyingBlood.Create(Owner.Pos+(0,0,y), Bld, Fuzzy, Scale:4*CFRandom(1, 2), Vel:Vel);
				S_StartSoundAt(Owner.Pos+(0,0,y), Handler.SpraySound, CHAN_AUTO, Volume: CFRandom(.1, .2)*MRGoreParts_SndVol*MRGoreParts_SpraySndVol, Pitch: CFrandom(1.1, 1.2));
			}
			if(Age<CRandom(-40, 60))
			{
				if(Handler.Effects.Size()>0)
					Handler.Effects[CRandom(0, Handler.Effects.Size()-1)].DoParticleEffect(Owner, Fuzzy, Angle, Pitch, Bld, 1, 1.5, 1, (0,0,Y*.9));
			}
		}
	}
}

Class MR_GoreParticlesCrushedThinker: MR_GoreParticlesThinker
{
	Color Bld;
	Sector CurSector;
	int StartAmount, RenderStyle, Direction, Glow;
	Vector2 Pos;//Thinker position
	Double PosZ, PrevZ, FOV;
	Bool Opened;//Ceiling is higher than floor
	Array<float> RandX, RandY;//Remains drops positions
	Array<Color> Colors;
	Array<Float> Sizes;
	
	Static Double AngleToVector2(Vector2 Pos, Vector2 Dir)
	{
		Vector2 Dif = Levellocals.Vec2Diff(Pos, Dir);
		
		Return VectorAngle(Dif.X, Dif.Y);
	}
	
	Static Double PitchToVector3(Vector3 Pos, Vector3 Dir)
	{
		Vector3 Dif = Levellocals.Vec3Diff(Pos, Dir);
		
		Return -atan2(Dif.Z, Dif.XY.Length());
	}
	
	Bool CheckSight(Vector3 Pos)
	{
		Let Plr = Players[ConsolePlayer].Camera;
		
		if(!Plr.Player)Return true;
		
		Vector3 Dir = (Plr.Pos.XY, Plr.Player.ViewZ);
		
		Vector3 direct = (Actor.AngleToVector(AngleToVector2(Pos.XY, Dir.XY), cos(PitchToVector3(Pos, Dir))), -sin(PitchToVector3(Pos, Dir)));
		Vector3 Dist = Level.Vec3Diff(Pos, Dir);
		
		let tracer = new('MR_GoreParticlesSightTracer');
		if(!tracer)return false;
		tracer.Trace(Pos, CurSector, direct, Dist.Length(), 0, Line.ML_BLOCKEVERYTHING);
		
		
		if(Tracer.HitPlayer)Return true;
		
		Tracer = new('MR_GoreParticlesSightTracer');
		
		direct = (Actor.AngleToVector(AngleToVector2(Pos.XY, Dir.XY), 
			cos(PitchToVector3((Pos.XY, CurSector.CenterCeiling()-1), Dir))), -sin(PitchToVector3((Pos.XY, CurSector.CenterCeiling()-1), Dir)));
		Dist = Level.Vec3Diff((Pos.XY, CurSector.CenterCeiling()-1), Dir);
		
		tracer.Trace((Pos.XY, CurSector.CenterCeiling()-1), CurSector, direct, Dist.Length(), 0, Line.ML_BLOCKEVERYTHING);
		
		Return Tracer.HitPlayer;
	}
	
	Bool MRGPartsCheckDraw(float dist, Vector3 Pos)
	{
		if(!MRGoreParts_Draw)Return false;
				
		Let Plr = Players[ConsolePlayer].Camera;
		if(!Plr)Return false;
		
		
		Vector3 Dif = LevelLocals.Vec3Diff(Plr.Pos, Pos);
		
		if(dist!=0 && Dif.Length()>Dist)Return false;
		
		if(abs(Actor.DeltaAngle(AngleToVector2(Plr.Pos.XY, Pos.XY), Plr.Angle))>FOV && Abs(Actor.DeltaAngle(PitchToVector3(Plr.Pos, Pos), Plr.Pitch))>70)Return false;
		
		Return CheckSight(Pos);
	}
	
	Override Void PostBeginPlay()
	{
		Super.PostBeginPlay();
		FOV = CVar.FindCVar("FOV").GetFloat();
		if(!Handler)Return;
		Handler.Crushed.Push(Self);
		
		StartAmount = RandX.Size();
		
		For(int i=0;i<RandX.Size();i++){//Setting up colors and sizes
			Float Bright = MRGoreParts_Brightness*CFrandom(.5, 1.5);
			Color TempCol = Color(int(Bld.R*Bright),int(Bld.G*Bright),int(Bld.B*Bright));
			Colors.Push(TempCol);
			Sizes.Push(MRGoreParts_Size*CFRandom(.4, 2)*3);
		}
	}
	
	Override Void OnDestroy()
	{
		if(!Handler)Return;
		Handler.Crushed.Delete(Handler.Crushed.Find(Self));
		Super.OnDestroy();
	}
		
	Override Void Tick(){
		if(!TickCheck())Return;
		
		if(RandX.Size()<1){Destroy();Return;}
		
		if(MRGoreParts_FullBright)Glow = SPF_FULLBRIGHT;
		else Glow = 0;
		
		if(CurSector.CenterFloor()>=CurSector.CenterCeiling()-8){
			
			if(Opened){//When the ceiling reaches the floor, leave some drops on the floor
				Opened = false;

				Float CurPos = CurSector.CenterFloor()+1;
				
				Let Plr = Players[ConsolePlayer].Camera;
				if(!Plr)Return;
				
				Vector3 Dif = Level.Vec3Diff((Pos, CurPos), Plr.Pos);
				Bool InDist = Dif.Length()<500;
				For(int i=0;i<RandX.Size();i++){
					if(CRandom(0, 10)>3)Continue;
										
					if(InDist){
						SpawnParticle(Colors[i], Glow, RenderStyle, 70, Sizes[i], 0, (RandX[i],RandY[i],CurPos), Alpha:MRGoreParts_Alpha, SizeStep:-(Sizes[i]/70.));
					}
					RandX.Delete(i);RandY.Delete(i);Colors.Delete(i);Sizes.Delete(i);
				}
			}
			Return;
		}
		Opened = true;
				
		PosZ = CurSector.CenterCeiling();
		
		
				
		if(Direction<0 && PosZ>=PrevZ){//Ceiling changed direction
			For(int i=CRandom(0, 2);i<5;i++)SpawnDrops(true);//Drops leaves ceiling
		}
		
		else if(Direction>0 && PosZ<=PrevZ){//Ceiling changed direction
			For(int i=CRandom(0, 2);i<4;i++)SpawnDrops(true);//Drops leaves ceiling
		}
		
		For(int i=CRandom(0, 2);i<4;i++)SpawnDrops();//Drops leaves ceiling
		
		Bool InSight=false;
		Vector2 LD, LU, RD, RU;
		LD = LU = RD = RU = (RandX[0], RandY[0]);
		
		For(int i=0;i<RandX.Size();i++){
			if(RandX[i]<=LD.X && RandY[i]<=LD.Y)LD = (RandX[i], RandY[i]);
			if(RandX[i]<=LU.X && RandY[i]>=LU.Y)LU = (RandX[i], RandY[i]);
			if(RandX[i]>=RD.X && RandY[i]<=RD.Y)RD = (RandX[i], RandY[i]);
			if(RandX[i]>=RU.X && RandY[i]>=RU.Y)RU = (RandX[i], RandY[i]);
		}

		Float Mid = CurSector.CenterCeiling()-CurSector.CenterFloor();
		While(True){//Sight check on the furthest spots
			if(MRGPartsCheckDraw(1000, (LD, CurSector.CenterFloor()+Mid*.5))){InSight=true;Break;}
			if(LD!=LU && MRGPartsCheckDraw(1000, (LU, CurSector.CenterFloor()+Mid*.5))){InSight=true;Break;}
			if(RD!=LU && RD!=LD && MRGPartsCheckDraw(1000, (RD, CurSector.CenterFloor()+Mid*.5))){InSight=true;Break;}
			if(RU!=RD && RU!=LD && RU!=LU && MRGPartsCheckDraw(1000, (RU, CurSector.CenterFloor()+Mid*.5))){InSight=true;Break;}
		}
		
		if(InSight)SpawnStatic();//Drops on the ceiling
		
		if(PosZ<PrevZ)Direction = -1;
		else if(PosZ>PrevZ)Direction = 1;
		else Direction = 0;
		
		PrevZ = PosZ;//Interpolation
	}
	
	Void SpawnDrops(Bool NoRandom=false, int Num=-1)
	{
		if(!NoRandom && RandX.Size()<CRandom(0, StartAmount))Return;
		if(RandX.Size()<1)Return;
		
		int Rand = Num;
		if(Rand==-1)Rand = CRandom(0, RandX.Size()-1);
		
		S_StartSoundAt((RandX[Rand], RandY[Rand], CurSector.CenterFloor()), Handler.DripSound, CHAN_AUTO, Volume:CFRandom(.1, .2)*MRGoreParts_SndVol*MRGoreParts_DripSndVol, attenuation:ATTN_STATIC);
		SpawnParticle(Colors[Rand], Glow, RenderStyle, 50, Sizes[Rand], 0, (RandX[Rand],RandY[Rand],PosZ), Accel:(0,0,-CFRandom(.3, .8)), Alpha:MRGoreParts_Alpha, SizeStep:-(Sizes[Rand]/50.));
		
		RandX.Delete(Rand);RandY.Delete(Rand);Colors.Delete(Rand);Sizes.Delete(Rand);
	}
	
	Void SpawnStatic()
	{
		Float Mid = CurSector.CenterCeiling()-CurSector.CenterFloor();
		Float CurPos = PrevZ;
		Float VelZ = PosZ-PrevZ;
		if(PosZ<PrevZ)CurPos = PosZ;
		if(PosZ==PrevZ){CurPos = PosZ;VelZ=0;}
		
		For(int i=0;i<RandX.Size();i++){
			SpawnParticle(Colors[i], SPF_REPLACE|Glow, RenderStyle, 1, Sizes[i], 0, (RandX[i],RandY[i],CurPos-1), (0,0,VelZ), Alpha:MRGoreParts_Alpha);
		}
	}
	
	Void DropAll()
	{
		Destroy();
		if(!Opened)Return;
		
		For(int i=0;i<RandX.Size();i++){
			SpawnDrops(true, i);
		}
	}
}

Class MR_GoreParticlesSpot: VisualThinker
{
	int Surface;//0 - Wall, 1 - Floor, 2 - Ceiling
	Bool FromCeiling;//In case spot placed on a wall of a sector that is originates from the ciling
	int Life, Age, Delay, Sliding;
	Double Height, StartScale, StartAlpha;
	Sector LinkedSector;
	Bool NoAlpha, PlaySound, InArray, Drip, Fallin;
	
	Override Void Tick()
	{
		Super.Tick();

		if(Delay>0 && Age>=Delay && Scale.X==0){
			Scale = (1, 1)*StartScale;
			if(PlaySound){
				Let Handler = MR_GoreParticlesHandler(EventHandler.Find("MR_GoreParticlesHandler"));
				if(Handler)S_StartSoundAt(Pos, Handler.DripSound, CHAN_AUTO, Volume:MRGoreParts_SndVol*MRGoreParts_DripSndVol);
			}
		}
				
		if(Age+20>=Life){
			if(Age>=Life){
				if(InArray){
					Let Handler = MR_GoreParticlesHandler(EventHandler.Find("MR_GoreParticlesHandler"));
					if(Handler)Handler.Spots.Delete(Handler.Spots.Find(Self));
				}
				Destroy();
				Return;
			}
			
			if(NoAlpha){
				Double Scal = StartScale*((Life-Age)/20.);
				
				Scale = (1, 1)*Scal;
			}
			else {
				Double Alph = StartAlpha*((Life-Age)/20.);
				
				Alpha = Alph;
			}
		}
		
		if(Drip && !Fallin && CRandom(0, 100)==1)Fallin = true;
		
		if(Fallin)Vel.Z -= CFRandom(.2, .4);
		
		else Switch(Surface){
			Case 0://Wall
				if(LinkedSector){
					if(FromCeiling){
						Pos.Z = LinkedSector.CenterCeiling()+Height;//Move spot with the wall
						if(Sliding>0){//Sliding down
							Height -= CFRandom(.005, .01);
							if(Height<0)Fallin = true;//If reached the bottom, fall down
							Sliding--;
						}
					}
					
					else {
						Pos.Z = LinkedSector.CenterFloor()-Height;//Move spot with the wall
						if(Sliding>0){//Sliding down
							Height += CFRandom(.005, .01);
							Sliding--;
						}
					}
				}
				else Pos.Z -= CFRandom(.005, .01);
				Break;
			Case 1://Floor
				if(CurSector)Pos.Z = CurSector.CenterFloor()+2;
				Break;
			Case 2://Ceiling
				if(CurSector)Pos.Z = CurSector.CenterCeiling()-2;
				Break;
		}
		
		Age++;
	}
	
	Override Void PostBeginPlay()
	{
		if(!Texture)Switch(MRGOreParts_SpotsStyle){
			Case 2:
				Texture = Texman.CheckForTexture("GParMst1");//Smooth
				StartScale *= .01;
				//Offset = (32, 32)*-StartScale;
				Break;
			Case 1:
				Texture = Texman.CheckForTexture("glpart2");//Round
				StartScale *= .004;
				//Offset = (64, 64)*-StartScale;
				Break;
			Case 0:
				Texture = Texman.CheckForTexture("GParMst2");//Square
				//Offset = (.5, .5)*-StartScale;
				Break;
		}
		
		if(Delay>0)Scale = (0, 0);
		else Scale = (1, 1)*StartScale;
		Alpha = StartAlpha;
		
		NoAlpha = MRGoreParts_LowAlpha;
		
		Fallin = false;
		
		Sliding = CRandom(35, 50);
	}
	
	Static MR_GoreParticlesSpot MRGSpawnSpot(Color Col, Vector3 Pos, int Life = 1, int Delay = 0, Bool PlaySound = 0, Double Scale = 1, Double Alpha = 1,
		int Surface = 1, Double Height = 0, Bool FromCeiling = 0, Sector LinkedSector = Null)
	{
		Let Spot = MR_GoreParticlesSpot(level.SpawnVisualThinker('MR_GoreParticlesSpot'));
		if(!Spot)Return Null;
		
		Spot.Pos = Pos;
		Spot.SColor = Col;
		Spot.Life = Life;
		Spot.Delay = Delay;
		Spot.Surface = Surface;
		if(Surface<1)Spot.Flags |= SPF_NO_XY_BILLBOARD;
		//if(MRGoreParts_FullBright)Spot.Flags |= SPF_FULLBRIGHT;
		Spot.Height = Height;
		Spot.FromCeiling = FromCeiling;
		Spot.LinkedSector = LinkedSector;
		Spot.PlaySound = PlaySound;
		Spot.StartScale = Scale;
		Spot.StartAlpha = Alpha;
		
		Return Spot;
	}
	
	Void Remove()
	{
		if(Age>Life-20)Destroy();
		else Age = Life-20;
	}
}

Class MR_GoreParticlesDroplet: VisualThinker
{
	Double Diff(Double a, Double b)
	{
		if(a>b)Return a-b;
		
		Return b-a;
	}
	
	Double Gravity, StartScale;
	int RenderStyle;
	
	Override Void PostBeginPlay()
	{
		if(!Texture)Switch(MRGOreParts_SpotsStyle){
			Case 2:
				Texture = Texman.CheckForTexture("GParMst1");//Smooth
				Scale *= .01;
				//Offset = (32, 32)*-StartScale;
				Break;
			Case 1:
				Texture = Texman.CheckForTexture("glpart2");//Round
				Scale *= .004;
				//Offset = (64, 64)*-StartScale;
				Break;
			Case 0:
				Texture = Texman.CheckForTexture("GParMst2");//Square
				//Offset = (.5, .5)*-StartScale;
				Break;
		}
		
		//Scale *= StartScale;
	}
	
	Override Void Tick()
	{
		Super.Tick();
		
		if(Level.IsFrozen())Return;
		
		Scale *= .95;
		if(Scale.X<.0001){Destroy();Return;}
		
		Bool Draw = MRGoreParts_Draw;
		
		//Double Angle = VectorAngle(Vel.X, Vel.Y);
		//Double Pitch = -atan2(Vel.Z, Vel.XY.Length());
		
		Vector3 dir = Vel;//(Actor.AngleToVector(Angle, cos(Pitch)), -sin(Pitch));
		
		Bool Landed = false;
		
		let tracer = new('MR_GoreParticlesSightTracer');

		tracer.CheckSurface = true;
		tracer.Trace(Pos, Level.PointInSector(Pos.XY), dir, Vel.Length()+5, 0, Line.ML_BLOCKEVERYTHING, true);
		
		if(Tracer.HitType!=TRACE_HitNone){
			HitSurface(Tracer.HitType, Tracer.HitLine, Tracer.HitPos);
			Landed = true;
		}
				
		if(CurSector){
			if(abs(Diff(Pos.Z, CurSector.CenterFloor()))<=Vel.Length()){HitSurface(TRACE_HitFloor, HitPos: (Pos.XY, CurSector.CenterFloor()));Landed = true;}
			if(abs(Diff(Pos.Z, CurSector.CenterCeiling())<=Vel.Length())){HitSurface(TRACE_HitCeiling, HitPos: (Pos.XY, CurSector.CenterCeiling()));Landed = true;}
		}
		
		if(Landed){Destroy();Return;}
		
		Prev = Pos;
		Pos += Vel;
		
		Vel.Z -= Gravity;
	}
	
	Virtual Void HitSurface(int HitType, Line HitLine=Null, Vector3 HitPos=(0,0,0))
	{
		if(!MRGoreParts_FloorSpots)Return;
		int Ofst = -1;
		int Glow = 0;
		Let Handler = MR_GoreParticlesHandler(EventHandler.Find("MR_GoreParticlesHandler"));
		if(!Handler)Return;
		S_StartSoundAt(Pos, Handler.DripSound, CHAN_AUTO, Volume:MRGoreParts_SndVol*MRGoreParts_DripSndVol, attenuation:ATTN_STATIC);
		if(MRGoreParts_FullBright)Glow = SPF_FULLBRIGHT;
		Switch(HitType){
		
			Case TRACE_HitWall:
				{
				Double Angle = VectorAngle(HitLine.Delta.X, HitLine.Delta.Y);
								
				
				Sector BackSector = HitLine.BackSector;
				if(BackSector==CurSector)BackSector = HitLine.FrontSector;
				
				Bool Plane;
				if(BackSector && HitPos.Z > BackSector.CenterCeiling())Plane = true;
					Let TempCol = SColor;
					
					Let PPos = HitPos;
					
					PPos += Level.Vec2Diff(PPos.XY, Pos.XY).Unit()*1.5;
					
					Double Height;
					if(BackSector){
						if(Plane)Height = PPos.Z-BackSector.CenterCeiling();
						else Height = BackSector.CenterFloor()-PPos.Z;
					}
					
					Let a = MR_GoreParticlesSpot.MRGSpawnSpot(TempCol, PPos, MRGoreParts_SpotsTime*35, 0, 0, CFRandom(.6, 1.1)*StartScale*MRGoreParts_Size, 1, 0, Height, Plane, BackSector);
					
					if(a){
						a.PostBeginPlay();
						a.SetRenderStyle(RenderStyle);
						a.Flags = Glow;
						a.InArray = true;
						Handler.UpdateSpots(a);
					}
				}
				Break;
				
			Case TRACE_HitFloor:
				Ofst = 1;
			Case TRACE_HitCeiling:
				{
				
					Let TempCol = SColor;
					
					Let a = MR_GoreParticlesSpot.MRGSpawnSpot(TempCol, HitPos + (0,0, Ofst), MRGoreParts_SpotsTime*StartScale*35, 0, 0, CFRandom(.6, 1.1)*MRGoreParts_Size, 1, (Ofst>0?1:2));
					
					if(a){
						a.PostBeginPlay();
						a.SetRenderStyle(RenderStyle);
						a.Flags = Glow;
						a.InArray = true;
						//a.Drip = true;
						Handler.UpdateSpots(a);
					}
				}
				Break;
		}
	}
	
	Static MR_GoreParticlesDroplet MRGSpawnDrop(Color Col, Vector3 Pos, Vector3 Vel = (0,0,0), Double Gravity = .5, Double Scale = 3, int RenderStyle = STYLE_NORMAL)
	{
		Let Drop = MR_GoreParticlesDroplet(level.SpawnVisualThinker('MR_GoreParticlesDroplet'));
		if(!Drop)Return Null;
		
		Drop.Pos = Pos;
		Drop.Vel = Vel;
		Drop.Gravity = Gravity;
		Drop.SColor = Col;
		if(MRGoreParts_FullBright)Drop.Flags |= SPF_FULLBRIGHT;
		Drop.StartScale = Scale;
		Drop.SetRenderStyle(RenderStyle);
		Drop.RenderStyle = RenderStyle;
		
		Return Drop;
	}
}