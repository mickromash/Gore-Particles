/*
	Blood effects actors(kinda) and classes
*/

Class MRGP_FlyingBlood: MRGP_Thinker//Quake gibs blood stream (basically client side actor)
{
	Vector3 Pos, Prev, Vel;
	Color Col;
	int Age, RenderStyle;
	Double Gravity, Scale, FOV;
	Sector CurSector;
	
	Static Double AngleToVector2(Vector2 Pos, Vector2 Dir)
	{
		Vector2 Dif = Levellocals.Vec2Diff(Pos, Dir);
		
		Return VectorAngle(Dif.X, Dif.Y);
	}
	
	Static Double PitchToVector3(Vector3 Pos, Vector3 Dir)
	{
		Vector3 Dif = Levellocals.Vec3Diff(Pos, Dir);
		
		Return -atan2(Dif.Z, Dif.XY.Length());
	}
		
	Bool CheckSight()
	{
		Let Plr = Players[ConsolePlayer].Camera;
		
		if(!Plr.Player)Return true;
		
		Vector3 Dir = (Plr.Pos.XY, Plr.Player.ViewZ);
		
		Vector3 direct = (Actor.AngleToVector(AngleToVector2(Pos.XY, Dir.XY), cos(PitchToVector3(Pos, Dir))), -sin(PitchToVector3(Pos, Dir)));
		Vector3 Dist = Level.Vec3Diff(Pos, Dir);
		
		let tracer = new('MRGP_SightTracer');
		if(!tracer)return false;
		tracer.Trace(Pos, Level.PointInSector(Pos.XY), direct, Dist.Length(), 0, Line.ML_BLOCKEVERYTHING);
		
		Return Tracer.HitPlayer;
	}
	
	Bool MRGPartsCheckDraw()
	{
		if(!MRGoreParts_Draw||!MRGoreParts_DrawFlyingBlood)Return false;
				
		Let Plr = Players[ConsolePlayer].Camera;
		if(!Plr)Return false;
			
		vector2 Dif = Level.Vec2Diff(Plr.Pos.XY, Pos.XY);
		
		if(abs(Actor.DeltaAngle(AngleToVector2(Plr.Pos.XY, Pos.XY), Plr.Angle))>FOV && Dif.Length()>Plr.Radius*2)Return false;
		
		Return CheckSight();
	}
	
	Static MRGP_FlyingBlood Create(Vector3 Pos, Color Col, int Flags, Float Gravity=.4, Float Scale=3, Vector3 Vel=(0,0,0))
	{
		Let a = New('MRGP_FlyingBlood');
		a.Init();
		if(a.bDestroyed)Return Null;
		a.Pos = Pos;
		a.Vel = Vel;
		a.Col = Col;
		a.Gravity = Gravity;
		a.Scale = Scale;
		if(Flags&SGPF_Fuzzy)a.RenderStyle = STYLE_Shadow;
		Return a;
	}
	
	Virtual Void Init()
	{
		if(!MRGoreParts_DrawFlyingBlood){Destroy();Return;}
		Handler = MRGP_Handler(EventHandler.Find("MRGP_Handler"));
		if(!Handler){Console.Printf("Gore-Particles:\cg Error! Event Handler wasn't found.");Destroy();Return;}
		Handler.Streams.Push(Self);
		Gravity = .4;
		Scale = 3;
		Fov = CVar.FindCVar("FOV").GetFloat();
	}
	
	Override Void OnDestroy()
	{
		if(!Handler){Super.OnDestroy();Return;}
		Handler.Streams.Delete(Handler.Streams.Find(Self));
		Super.OnDestroy();
	}
	
	Override Void Tick()
	{
		if(Level.IsFrozen())Return;
		
		Age++;
		if(Age>35*3){Destroy();Return;}
		
		Let Draw = MRGPartsCheckDraw();
		
		Double Angle = VectorAngle(Vel.X, Vel.Y);
		Double Pitch = -atan2(Vel.Z, Vel.XY.Length());
		
		Vector3 dir = (Actor.AngleToVector(Angle, cos(Pitch)), -sin(Pitch));
		
		Bool Landed = false;
		
		let tracer = new('MRGP_SightTracer');

		tracer.CheckSurface = true;
		tracer.Trace(Pos, Level.PointInSector(Pos.XY), dir, Vel.Length()+5, 0, Line.ML_BLOCKEVERYTHING, true);
		
		if(Tracer.HitType!=TRACE_HitNone){
			HitSurface(Tracer.HitType, Tracer.HitLine, Tracer.HitPos);
			Landed = true;
		}
		
		CurSector = LevelLocals.PointInSector(Pos.XY+Vel.XY);
		
		if(CurSector){
			if(CurSector.CenterFloor()>=Pos.Z){HitSurface(TRACE_HitFloor, Null, (Pos.XY, CurSector.CenterFloor()));Landed = true;}
			else if(CurSector.CenterCeiling()<=Pos.Z){HitSurface(TRACE_HitCeiling, Null, (Pos.XY, CurSector.CenterCeiling()));Landed = true;}
			else if(CurSector.CenterFloor()+20>=Pos.Z){//Falling drops
				int Glow = 0;
				if(MRGoreParts_FullBright)Glow = SPF_FULLBRIGHT;
				Float Bright = MRGoreParts_Brightness*CFrandom(.5, .9);
				Color TempCol = Color(int(Col.R*Bright),int(Col.G*Bright),int(Col.B*Bright));
					
				Vector3 PPos = (Pos.XY, CurSector.CenterFloor()+1);
				PPos.XY += (CFRandom(-Scale, Scale), CFRandom(-Scale, Scale));
				
				Let a = MRGP_Spot.MRGSpawnSpot(TempCol, PPos, MRGoreParts_SpotsTime*35, 0, 0, CFRandom(.6, 1.1)*Scale*MRGoreParts_Size);
					
				if(a){
					a.SetRenderStyle(RenderStyle);
					a.Flags = Glow;
					a.InArray = true;
					a.Delay = (Pos.Z-CurSector.CenterFloor())*.5;
					For(int i=0;i<Max(0, Handler.Spots.Size()-MRGoreParts_MaxSpots+1);i++){
						if(Handler.Spots[i]){Handler.Spots[i].Remove();Handler.Spots.Delete(i);i--;}
					}
					Handler.Spots.Push(a);
				}
			}
		}
		
		if(Landed){Destroy();Return;}
		
		Prev = Pos;
		Pos += Vel;
		
		if(Draw){
			DrawTrail();
		}
		
		Vel.Z -= Gravity;
	}
	
	Virtual Void DrawTrail()
	{
		int Glow = 0;
		if(MRGoreParts_FullBright)Glow = SPF_FULLBRIGHT;
		Float Brightnes = MRGoreParts_Brightness*CFrandom(.5, 1.5);
		
		Color CurCol = Color(int(Col.R*Brightnes), int(Col.G*Brightnes), int(Col.B*Brightnes));
		
		Double Dist = 1;
		if(Players[ConsolePlayer].Camera){
			Vector3 Dif = Level.Vec3Diff(Pos, Players[ConsolePlayer].Camera.Pos);
			Dist = Max(1, 1+(Dif.Length()-80)*.0015*MRGoreParts_Distance);
		}
		
		Float Bright = MRGoreParts_Brightness*CFrandom(.5, 1.5);
		Color TempCol = Color(int(Col.R*Bright),int(Col.G*Bright),int(Col.B*Bright));
		
		SpawnParticle(TempCol, Glow, RenderStyle, 1, Scale*MRGoreParts_Size*Dist, 0, Pos, Vel, Alpha:MRGoreParts_Alpha, SizeStep:0);
		
		
		Vector3 Dif = Level.Vec3Diff(Pos, Prev);
		For(float i=0;i<Dif.Length();i+=Max(.5, Scale*.5*Max(1, Dist*.01)))
		{
			Float Step = i;
			Step /= Dif.Length();

			Float Brightes = MRGoreParts_Brightness*CFrandom(.5, 1.5);
			CurCol = Color(int(Col.R*Brightnes), int(Col.G*Brightnes), int(Col.B*Brightnes));
			
			Float Rand = CFRandom(-Scale*MRGoreParts_Size*.1, Scale*MRGoreParts_Size*.1);
			
			SpawnParticle(CurCol, Glow, RenderStyle, 20, Scale*MRGoreParts_Size*Dist,
				0, Pos + (Dif.X*Step+Vel.X*.5+Rand, Dif.Y*Step+Vel.Y*.5+Rand, Dif.Z*Step+Vel.Z*.5+Rand), Accel:(0,0,-Gravity*.5), Alpha:MRGoreParts_Alpha,
					SizeStep:-Scale*MRGoreParts_Size*.9*.05);
		}
	}
	
	Virtual Void HitSurface(int HitType, Line HitLine=Null, Vector3 HitPos=(0,0,0))
	{
		int Ofst = -1;
		int Glow = 0;
		S_StartSoundAt(Pos, Handler.DripSound, CHAN_AUTO, Volume:MRGoreParts_SndVol*MRGoreParts_DripSndVol, attenuation:ATTN_STATIC);
		if(!MRGoreParts_Draw)Return;
		if(MRGoreParts_FullBright)Glow = SPF_FULLBRIGHT;
		Switch(HitType){
		
			Case TRACE_HitWall:
				Double Angle = VectorAngle(HitLine.Delta.X, HitLine.Delta.Y);
				
				For(int i=CRandom(0, 2);i<7;i++){//Splash
					
					Float Pitch = CRandom(0, 40);
					Float Bright = MRGoreParts_Brightness*CFrandom(.5, 1.5);
					Color TempCol = Color(int(Col.R*Bright),int(Col.G*Bright),int(Col.B*Bright));
					int Life = CRandom(15, 21);
					Float Size = CFRandom(.2, .5)*Scale*MRGoreParts_Size;
										
					SpawnParticle(TempCol, Glow, RenderStyle, Life, Size, 0, HitPos - (0,0,i),
						-Vel*CFRandom(.2, .4)+(Actor.AngleToVector(Angle-90+CRandom(-50, 50), 2), Sin(CRandom(0, 50))*2),
						(0,0,-.4), MRGoreParts_Alpha, 0, -(Size/Life));
				}
				
				if(!MRGoreParts_FloorSpots)Return;
				Sector BackSector = HitLine.BackSector;
				if(BackSector==CurSector)BackSector = HitLine.FrontSector;
				
				Bool Plane;
				if(BackSector && HitPos.Z > BackSector.CenterCeiling())Plane = true;
				
				
				
				For(int i=CRandom(0, 3);i<7;i++){//Spots
					Float Bright = MRGoreParts_Brightness*CFrandom(.5, .9);
					Color TempCol = Color(int(Col.R*Bright),int(Col.G*Bright),int(Col.B*Bright));
					
					Vector3 PPos = HitPos + (Actor.AngleToVector(Angle, CFRandom(-3, 3)), CFRandom(-3, 3)-i);
					
					PPos += Level.Vec2Diff(PPos.XY, Pos.XY).Unit()*1.5;
					
					Double Height;
					if(BackSector){
						if(Plane)Height = PPos.Z-BackSector.CenterCeiling();
						else Height = BackSector.CenterFloor()-PPos.Z;
					}
					
					Let a = MRGP_Spot.MRGSpawnSpot(TempCol, PPos, MRGoreParts_SpotsTime*35, 0, 0, CFRandom(.6, 1.1)*Scale*MRGoreParts_Size, 1, 0, Height, Plane, BackSector);
					
					if(a){
						a.SetRenderStyle(RenderStyle);
						a.Flags = Glow;
						a.InArray = true;
						Handler.UpdateSpots(a);
					}
				}
				Break;
				
			Case TRACE_HitFloor:
				Ofst = 1;
			Case TRACE_HitCeiling:
				For(int i=CRandom(0, 2);i<7;i++){//Splash
					
					Float Bright = MRGoreParts_Brightness*CFrandom(.5, 1.5);
					Color TempCol = Color(int(Col.R*Bright),int(Col.G*Bright),int(Col.B*Bright));
					
					int Life = CRandom(15, 21);
					Float Size = CFRandom(.2, .5)*Scale*MRGoreParts_Size;
					
					SpawnParticle(TempCol, Glow, RenderStyle, Life, Size, 0,
						HitPos - (0,0,i), -Vel*CFRandom(.2, .4)+(Actor.AngleToVector(Angle-90+CRandom(-50, 50), 2), Sin(CRandom(0, 50))*Ofst*2),
						(0,0,-.4), MRGoreParts_Alpha, 0, -(Size/Life));
				}
				
				if(!MRGoreParts_FloorSpots)Return;
				For(int i=CRandom(0, 3);i<7;i++){//Spots
				
					Float Bright = MRGoreParts_Brightness*CFrandom(.5, .9);
					Color TempCol = Color(int(Col.R*Bright),int(Col.G*Bright),int(Col.B*Bright));
					
					Let a = MRGP_Spot.MRGSpawnSpot(TempCol, HitPos + (CFRandom(-3, 3), CFRandom(-3, 3), Ofst), MRGoreParts_SpotsTime*35, 0, 0, CFRandom(.6, 1.1)*Scale*MRGoreParts_Size, 1, (Ofst>0?1:2));
					
					if(a){
						a.SetRenderStyle(RenderStyle);
						a.Flags = Glow;
						a.InArray = true;
						if(Ofst<1 && i%2==0)a.Drip = true;
						Handler.UpdateSpots(a);
					}
				}
				Break;
		}
	}
}

class MRGP_SightTracer : LineTracer
{
	Bool HitPlayer, CheckSurface;
	int HitType;
	Vector3 HitPos;
	Line HitLine;
	
	override ETraceStatus TraceCallback()
	{
		HitType = TRACE_HitNone;
		switch(results.HitType)
		{
			case TRACE_HitActor:
				if(CheckSurface)Return TRACE_Skip;
				if(results.HitActor && results.HitActor == Players[ConsolePlayer].Camera)
				{
					HitPlayer = true;
					Return TRACE_Stop;
				}
				Return TRACE_Skip;
			
			case TRACE_HitWall:
				if(CheckSurface)HitLine = Results.HitLine;
			case TRACE_HitFloor://Doesn't work for some reason
			case TRACE_HitCeiling:
				if(CheckSurface){HitType = Results.HitType;HitPos = results.HitPos;Return TRACE_Stop;}
			case TRACE_HasHitSky:
				Return TRACE_Stop;
		}

		return TRACE_Skip;
	}
}

enum MRGP_EffectFlag{
	SGPF_NoDist = 1,//Distance won't affect particles velocity and sizes
	SGPF_FixAmount = 2,//Ignore particles amount CVar
	SGPF_NoVel = 4,
	SGPF_Fuzzy = 8,
	SGPF_Test = 16,
	SGPF_Glow = 32,
};

Class MRGP_Effect play abstract
{
	Virtual int DoParticleEffect(Actor mo, int Flags = 0, Double Angle = 0, Double Pitch = 0, Color Col = 0, double Amount = 1, Double Scale = 1, Double Alpha = 1, Vector3 Offset = (0,0,0), Double LifeM = 1, Vector3 Force = (0,0,0), Double MoVel = 0)
	{Return 0;}
	/*
		mo - actor that spawns particles
		Amount - particles amount multiplier
		Flags - check MRGP_EffectFlag enum
		Angle - particles direction angle
		Pitch - particles direction pitch
		Col - particles base color
		Scale - particles sizes multiplier
		Alpha - Alpha multiplier
		Offset - offsets particles spawn point from actor position (absolute)
		LifeM - particles lifetime multiplier
		Force - additional velocity
		MoVel - multiplies actor velocity that will be added to particles
	*/
	Static Void SpawnEffect(Class<Object> Effect, Actor mo, int Flags = 0, Double Angle = 0, Double Pitch = 0, Color Col = 0, double Amount = 1, Double Scale = 1, Double Alpha = 1, Vector3 Offset = (0,0,0), Double LifeM = 1, Vector3 Force = (0,0,0), Double MoVel = 0)
	{
		if(!mo)Return;
		Let Spawner = MRGP_Effect(New(Effect));
		
		if(Spawner){
			Spawner.DoParticleEffect(mo, Flags, Angle, Pitch, Col, Amount, Scale, Alpha, Offset, LifeM, Force, MoVel);
			Spawner.Destroy();
		}
	}

	//Data for included effects menu
	Clearscope Virtual int GetID(){Return -1;}
	Clearscope Virtual String GetName(){Return StringTable.Localize("$"..GetClassName());}
	Clearscope Virtual Bool UsesAlpha(){Return false;}
	
	int MinParticles, MaxParticles;
	Void CountParticles(int cycles=1)
	{
		MaxParticles = MinParticles = -1;
		For(int i=0;i<cycles;i++){
			int Amt = DoParticleEffect(players[consolePlayer].Camera, SGPF_TEST);
			
			if(MaxParticles==-1){MinParticles = MaxParticles = Amt;Continue;}
			
			if(MinParticles>Amt)MinParticles = Amt;
			else if(MaxParticles<Amt)MaxParticles = Amt;
		}
	}
}

Class MRGP_Effect_SimpleSplash: MRGP_Effect
{
	Override int DoParticleEffect(Actor mo, int Flags, Double Angle, Double Pitch, Color Col, double Amount, Double Scale, Double Alpha, Vector3 Offset, Double LifeM, Vector3 Force, Double MoVel)
	{
		if(!mo||!Players[ConsolePlayer].Camera)Return 0;
		
		if(!MRGoreParts_Draw)Return 0;
		if(!(Flags&SGPF_FixAmount))Amount *= MRGoreParts_Amount;
		if(Amount<=0)Return 0;
		
		int Particles;
		
		Bool Water = mo.WaterLevel>2;
		
		Float Dist = MRGP_DistanceMult;
		
		if(Flags&SGPF_NODIST)Dist = 1;
		else
		{
			Dist *= Max(1, 1+(MRGParts.MRDistance3D(mo, Players[ConsolePlayer].Camera)-80)*.0015*MRGoreParts_Distance);
			if(Scale>1)Dist/=Scale;
		}
		
		int Glow = 0;
		if(MRGoreParts_FullBright)Glow = SPF_FULLBRIGHT;
		int Fuzzy = STYLE_NONE;
		if(Flags&SGPF_Fuzzy)Fuzzy = STYLE_Shadow;
		
		Float Mult = (CRandom(1, 3)*3+1)/Max(1, Dist*.1)*Amount;
		if(Water)Mult = Max(1, Mult*.5);
		
		Let LowAlpha = MRGoreParts_LowAlpha;
		Let Alph = MRGoreParts_Alpha;
		
		For(float i1=0;i1<Mult;i1++)
		{
			Double Ang = CRandom(0, 360);
			Double Leng = CFRandom(0, .3);
			Vector3 Strn = (CFRandom(.1, 1), Cos(Ang)*Leng, Sin(Ang)*Leng);
			Vector3 Vel = (Actor.AngleToVector(Angle, Strn.X)*Cos(Abs(Pitch)), Abs(Cos(Pitch))*Strn.Z + -Sin(Pitch)*Strn.X);
			Vel.XY += Actor.AngleToVector(Angle+90, Strn.Y);
			Vel.XY += Actor.AngleToVector(Angle, Strn.Z)*Sin(Pitch);
			
			Float Bright = Max(MRGoreParts_Brightness*.5, Min(MRGoreParts_Brightness*1.5, MRGoreParts_Brightness+Vel.Z*1.5))+CFRandom(-.05, .05);
			Color ColTmp = Color(int(Col.R*Bright), int(Col.G*Bright), int(Col.B*Bright));
			
			Vel += Force;
			Vel *= MRGoreParts_Speed;
			Vel *= Dist;
			Vel *= Scale;
			Vel += mo.Vel*moVel;
			
			if(Water)Vel *= .5;
			
			Float Life = Min(45, 10/Strn.Length())/MRGoreParts_Speed*LifeM;
			if(Water)Life *= 2;
			
			Double Size = CFRandom(.9, 3)*Dist*Scale*MRGoreParts_Size;
			Vector3 Accel = -Vel*CFRandom(.004, .01);
			Accel.Z -= MRGoreParts_Gravity*.1;
			
			Vector3 Ofst = Vel;
			Ofst *= Mult/(i1+1);
			
			Float ReSize, Fade;
			ReSize = -(Size/Life);
			if(!LowAlpha){Fade = -1; ReSize *= .4;}
			
			if(!(Flags&SGPF_TEST))mo.A_SpawnParticleEx(ColTmp, Texman.CheckForTexture("glpart"), Fuzzy, Glow, Life, Size, 0, Ofst.X*CFRandom(.3, .7)+Offset.X,Ofst.Y*CFRandom(.3, .7)+Offset.Y,5+Ofst.Z*CFRandom(.3, .7)+Offset.Z,
				Vel.X, Vel.Y, Vel.Z, Accel.X, Accel.Y, Accel.Z, Alph, Fade, ReSize);
			Particles++;
		}
		
		Return Particles;
	}
	
	Override int GetID(){Return 0;}
}

Class MRGP_Effect_Sprays: MRGP_Effect
{Override int GetID(){Return 1;}}

Class MRGP_Effect_Mist: MRGP_Effect
{
	Override int DoParticleEffect(Actor mo, int Flags, Double Angle, Double Pitch, Color Col, double Amount, Double Scale, Double Alpha, Vector3 Offset, Double LifeM, Vector3 Force, Double MoVel)
	{
		if(!mo||!Players[ConsolePlayer].Camera)Return 0;
		
		if(!MRGoreParts_Draw)Return 0;
		//if(!(Flags&SGPF_FixAmount))Amount *= MRGoreParts_Amount;
		if(Amount<=0)Return 0;
		
		int Particles;
		
		Bool Water = mo.WaterLevel>2;
		
		Float Dist = MRGP_DistanceMult;
		
		if(Flags&SGPF_NODIST)Dist = 1;
		else
		{
			Dist *= Max(1, 1+(MRGParts.MRDistance3D(mo, Players[ConsolePlayer].Camera)-80)*.0015*MRGoreParts_Distance);
			if(Scale>1)Dist/=Scale;
		}
		
		int Glow = 0;
		if(MRGoreParts_FullBright)Glow = SPF_FULLBRIGHT;
		int Fuzzy = STYLE_NONE;
		if(Flags&SGPF_Fuzzy)Fuzzy = STYLE_Shadow;
		
		int Amnt = CRandom(1, 3)/Max(1, Dist*.1)*2*Amount;
		if(Flags&SGPF_FixAmount)Amnt = Amount;
		
		TextureId Texture;
			
		Switch(MRGoreParts_MistTexture)
		{
			Case 0:Texture = Texman.CheckForTexture("GParMst");Break;
			Default: Texture = Texman.CheckForTexture("GParMst"..MRGoreParts_MistTexture);Break;
			Case 3:Texture = Texman.CheckForTexture("glpart");Break;
		}
		
		For(int i=0;i<Amnt;i++)
		{
			Vector2 HorzStrn = (CFRandom(-.2, .2), CFRandom(-.2, .2));
			Vector3 Strn = (CFRandom(.05, .2), HorzStrn.X, HorzStrn.Y);
			Vector3 Vel = (Actor.AngleToVector(Angle, Strn.X)*Cos(Abs(Pitch)), Abs(Cos(Pitch))*Strn.Z + -Sin(Pitch)*Strn.X);
			Vel.XY += Actor.AngleToVector(Angle+90, Strn.Y);
			Vel.XY += Actor.AngleToVector(Angle, Strn.Z)*Sin(Pitch);
			
			Float Bright = Max(MRGoreParts_Brightness*.5, Min(MRGoreParts_Brightness*1.5, MRGoreParts_Brightness+Vel.Z))+CFRandom(-.05, .05);
			Color ColTmp = Color(int(Col.R*Bright), int(Col.G*Bright), int(Col.B*Bright));
			
			Vel += Force;
			Vel *= MRGoreParts_Speed;
			Vel *= Dist;
			Vel += mo.Vel*moVel;
			
			if(Water)Vel *=.5;
			
			Vector3 Accel = -Vel*CFRandom(.004, .01);
			Accel.Z -= MRGoreParts_Gravity*.01;
			
			Float Life = (Min(50, 11/Strn.Length())*LifeM)/MRGoreParts_Speed;
			if(Water)Life = Min(90, Life*2);
			
			Double Size = Scale*MRGoreParts_Size*(abs(HorzStrn.Length()*20))*Dist;
			if(Flags&SGPF_NoVel)Size = Scale*Dist;
			
			Double PAlpha = CFRandom(.2, .4);
			if(Alpha!=1)PAlpha = Alpha;
			
			if(!(Flags&SGPF_TEST))mo.A_SpawnParticleEx(ColTmp, Texture, Fuzzy, Glow, Life, Size, 0,
				Offset.X,Offset.Y,5+Offset.Z,
				Vel.X,Vel.Y,Vel.Z,
				Accel.X,Accel.Y,Accel.Z,
				PAlpha, -(Life/PAlpha), Size*MRGoreParts_Speed*.1*(Water?.5:1)
			);
			
			Particles++;
		}
		
		Return Particles;
	}
	Override int GetID(){Return 2;}
	
	Override Bool UsesAlpha(){Return true;}
}

Class MRGP_Effect_BeautifulSpray: MRGP_Effect
{
	Override int DoParticleEffect(Actor mo, int Flags, Double Angle, Double Pitch, Color Col, double Amount, Double Scale, Double Alpha, Vector3 Offset, Double LifeM, Vector3 Force, Double MoVel)
	{
		if(!mo||!Players[ConsolePlayer].Camera)Return 0;
		
		if(!MRGoreParts_Draw)Return 0;
		if(!(Flags&SGPF_FixAmount))Amount *= MRGoreParts_Amount;
		if(Amount<=0)Return 0;
		
		int Particles;
		
		Bool Water = mo.WaterLevel>2;
		if(Water)Amount *= .5;
		
		Float Dist = MRGP_DistanceMult;
		
		if(Flags&SGPF_NODIST)Dist = 1;
		else
		{
			Dist *= Max(1, 1+(MRGParts.MRDistance3D(mo, Players[ConsolePlayer].Camera)-80)*.0015*MRGoreParts_Distance);
			if(Scale>1)Dist/=Scale;
		}
		
		int Glow = 0;
		if(MRGoreParts_FullBright)Glow = SPF_FULLBRIGHT;
		int Fuzzy = STYLE_NONE;
		if(Flags&SGPF_Fuzzy)Fuzzy = STYLE_Shadow;
		
		Pitch -= CFRandom(5, 8);
		//Angle += CRandom(-30, 30);
		Double Forw = CFRandom(1.4, 3);
		Vector3 Strn;
		Double Size = CFRandom(1.2, 1.6)*MRGoreParts_Size*Dist;
		Float Life = CFRandom(35, 40)/MRGoreParts_Speed*LifeM;
		if(Water)Life *= 2;
		
		Float Step = Max(.001, .05*Max(1, Dist*.1)/Amount);
		
		Let Alph = MRGoreParts_Alpha;
		Let LowAlpha = MRGoreParts_LowAlpha;
		
		For(float j=.1;j<1.1;j+=Step)
		{
			Double Ang = CRandom(0, 360);
			Double Leng = CFRandom(0, .1*j);
			Strn.X = Forw*j*.5;
			Strn.Y = -Cos(Ang)*Leng;
			Strn.Z = -Sin(Ang)*Leng;
			Vector3 Vel = (Actor.AngleToVector(Angle, Strn.X)*Cos(Abs(Pitch)), Abs(Cos(Pitch))*Strn.Z -Sin(Pitch)*Strn.X);
			Vel.XY += Actor.AngleToVector(Angle+90, Strn.Y);
			Vel.XY += Actor.AngleToVector(Angle, Strn.Z)*Sin(Pitch);
			
			Vector3 Accel = (Actor.AngleToVector(Angle, Strn.X)*Cos(Abs(Pitch)), Abs(Cos(Pitch))*Strn.Z -Sin(Pitch)*Strn.X);
			Accel *= CFRandom(.01, .02);
			Accel.XY += Actor.AngleToVector(Angle+90, -Strn.Y*.1);
			Accel.XY += Actor.AngleToVector(Angle, -Strn.Z)*Sin(Pitch);
			
			Float Bright = Max(MRGoreParts_Brightness*.5, Min(MRGoreParts_Brightness*1.5, MRGoreParts_Brightness+(Vel.Z+Accel.Z)*Cos(Abs(Pitch)*.5)));
			Bright += CFRandom(-.05, .05);
			Color ColTmp = Color(int(Col.R*Bright), int(Col.G*Bright), int(Col.B*Bright));
			
			Vel += Force;
			Vel *= MRGoreParts_Speed;
			Vel *= Dist;
			Vel *= Scale;
			Vel += mo.Vel*moVel;
			
			Accel = -Accel;
			Accel *= Dist;
			Accel *= Scale;
			
			if(Water){Vel *= .5;Accel *= .5;}
			
			Float ReSize, Fade;
			ReSize = -((Size+j*3)/Life);
			if(!LowAlpha){Fade = -1; ReSize *= .4;}
			
			if(!(Flags&SGPF_TEST))mo.A_SpawnParticleEx(ColTmp, Texman.CheckForTexture("glpart"), Fuzzy, Glow, Life+5, (Size+j*3)*CFRandom(.9, 1.1), 0, Vel.X*j+Offset.X, Vel.Y*j+Offset.Y, 5+Vel.Z*j+Offset.Z,
				Vel.X, Vel.Y, Vel.Z, Accel.X,Accel.Y,Accel.Z-((j-.1)*.015)*(1+MRGoreParts_Gravity*4), Alph, Fade, ReSize);
			Life-=.5/MRGoreParts_Speed*LifeM;
			
			Particles++;
		}
		
		Return Particles;
	}
	
	Override int GetID(){Return 3;}
}

Class MRGP_Effect_BeautifulSprayGrowing: MRGP_Effect
{
	Override int DoParticleEffect(Actor mo, int Flags, Double Angle, Double Pitch, Color Col, double Amount, Double Scale, Double Alpha, Vector3 Offset, Double LifeM, Vector3 Force, Double MoVel)
	{
		if(!mo||!Players[ConsolePlayer].Camera)Return 0;
		
		if(!MRGoreParts_Draw)Return 0;
		if(!(Flags&SGPF_FixAmount))Amount *= MRGoreParts_Amount;
		
		int Particles;
		
		Bool Water = mo.WaterLevel>2;
		if(Water)Amount *= .5;
		
		Float Dist = MRGP_DistanceMult;
		
		if(Flags&SGPF_NODIST)Dist = 1;
		else
		{
			Dist *= Max(1, 1+(MRGParts.MRDistance3D(mo, Players[ConsolePlayer].Camera)-80)*.0015*MRGoreParts_Distance);
			if(Scale>1)Dist/=Scale;
		}
		
		int Glow = 0;
		if(MRGoreParts_FullBright)Glow = SPF_FULLBRIGHT;
		int Fuzzy = STYLE_NONE;
		if(Flags&SGPF_Fuzzy)Fuzzy = STYLE_Shadow;
		
		Pitch -= CFRandom(5, 8);
		Angle += CRandom(-30, 30);
		Double Forw = CFRandom(1.4, 3);
		Vector3 Strn;
		Double Size = CFRandom(1.2, 1.6)*MRGoreParts_Size*Dist;
		Float Life = CFRandom(35, 40)/MRGoreParts_Speed*LifeM;
		if(Water)Life *= 2;
		
		Float Step = Max(.001, .05*Max(1, Dist*.1)/Amount);	
		For(float j=.1;j<1.1;j+=Step)
		{
			Double Ang = CRandom(0, 360);
			Double Leng = CFRandom(0, .1*j);
			Strn.X = Forw*j*.25;
			Strn.Y = -Cos(Ang)*Leng;
			Strn.Z = -Sin(Ang)*Leng;
			Vector3 Vel = (Actor.AngleToVector(Angle, Strn.X)*Cos(Abs(Pitch)), Abs(Cos(Pitch))*Strn.Z -Sin(Pitch)*Strn.X);
			Vel.XY += Actor.AngleToVector(Angle+90, Strn.Y);
			Vel.XY += Actor.AngleToVector(Angle, Strn.Z)*Sin(Pitch);
			
			Vel += Force;
			Vel *= MRGoreParts_Speed;
			Vel *= Dist;
			Vel *= Scale;
			Vel += mo.Vel*moVel;
			
			
			Vector3 Accel = (Actor.AngleToVector(Angle, Strn.X)*Cos(Abs(Pitch)), Abs(Cos(Pitch))*Strn.Z -Sin(Pitch)*Strn.X);
			Accel *= CFRandom(.01, .02);
			Accel.XY += Actor.AngleToVector(Angle+90, -Strn.Y*.1);
			Accel.XY += Actor.AngleToVector(Angle, -Strn.Z)*Sin(Pitch);
			
			Accel = -Accel;
			Accel *= Dist;
			Accel *= Scale;
			
			if(Water){Vel *= .5;Accel *= .5;}
			
			Float Bright = Max(MRGoreParts_Brightness*.5, Min(MRGoreParts_Brightness*1.5, (Strn.Z/(.3*j)+.75)*2));
			Bright += CFRandom(-.05, .05);
			
			Color ColTmp = Color(int(Col.R*Bright), int(Col.G*Bright), int(Col.B*Bright));
			
			if(!(Flags&SGPF_TEST))mo.A_SpawnParticleEx(ColTmp, Texman.CheckForTexture("glpart"), Fuzzy, Glow, Life+5, (Size+j*3)*CFRandom(.9, 1.1), 0, Vel.X*j+Offset.X, Vel.Y*j+Offset.Y, 5+Vel.Z*j+Offset.Z,
				Vel.X, Vel.Y, Vel.Z, Accel.X,Accel.Y,Accel.Z-((j-.1)*.01)*(1+MRGoreParts_Gravity*4), MRGoreParts_Alpha, -1, ((Size+j*3)/Life)*.05);
			Life-=.5/MRGoreParts_Speed*LifeM;
			
			Particles++;
		}
		
		Return Particles;
	}
	
	Override int GetID(){Return 4;}
	Override Bool UsesAlpha(){Return true;}
}

Class MRGP_Effect_CurveLine: MRGP_Effect
{
	Override int DoParticleEffect(Actor mo, int Flags, Double Angle, Double Pitch, Color Col, double Amount, Double Scale, Double Alpha, Vector3 Offset, Double LifeM, Vector3 Force, Double MoVel)
	{
		if(!mo||!Players[ConsolePlayer].Camera)Return 0;
		
		if(!MRGoreParts_Draw)Return 0;
		if(!(Flags&SGPF_FixAmount))Amount *= MRGoreParts_Amount;
		if(Amount<=0)Return 0;
		Amount = Min(1.1, Amount);
		Float Dist = MRGP_DistanceMult;
		
		int Particles;
		
		Bool Water = mo.WaterLevel>2;
		if(Water)Amount *= .5;
		
		if(Flags&SGPF_NODIST)Dist = 1;
		else
		{
			Dist *= Max(1, 1+(MRGParts.MRDistance3D(mo, Players[ConsolePlayer].Camera)-80)*.0015*MRGoreParts_Distance);
			if(Scale>1)Dist/=Scale;
		}
		
		int Glow = 0;
		if(MRGoreParts_FullBright)Glow = SPF_FULLBRIGHT;
		int Fuzzy = STYLE_NONE;
		if(Flags&SGPF_Fuzzy)Fuzzy = STYLE_Shadow;
		
		Pitch -= CFRandom(5, 10);
		//Angle += CRandom(-15, 15);
		Double Forw = .4;//CFRandom(.01, .2);
		Double Size = CFRandom(3.4, 3.7)*MRGoreParts_Size*Dist;
		Float Life = CFRandom(30, 34)/MRGoreParts_Speed*LifeM;
		if(Water)Life *= 2;
		Double StartLife = Life;
		
		Double Roll = CRandom(175, 360);
		
		Double CircleLength = Random(120, 360*Min(1, MRGoreParts_Amount));
		Float Step = Max(.1, Size*.75*Max(1, Dist*.1)/Amount);
		
		Let Alph = MRGoreParts_Alpha;
		Let LowAlpha = MRGoreParts_LowAlpha;
		
		For(Double j=-CircleLength/2;j<CircleLength/2;j+=Step)
		{
			Double Ang = (j+CFRandom(-1.5, 1.5))*Cos(Roll);
			Ang = Angle + Ang;
			Double Pit = (j+CFRandom(-1.5, 1.5))*Sin(Roll);
			Pit = Pitch + Pit;
			
			Vector3 Vel = (Actor.AngleToVector(Ang, Forw)*Cos(Abs(Pit)), (-Sin(Pit)*(1.-abs(j/(CircleLength/2))))*Forw);
			
			Float Bright = Max(MRGoreParts_Brightness*.5, Min(MRGoreParts_Brightness*1.5, MRGoreParts_Brightness+.1+Vel.Z*2));
			Bright += CFRandom(-.05, .05);
			Color ColTmp = Color(int(Col.R*Bright), int(Col.G*Bright), int(Col.B*Bright));
			
			Vel += Force;
			Vel *= MRGoreParts_Speed;
			Vel *= Scale;
			Vel *= Dist;
			Vel += mo.Vel*moVel;
			
			Double AccelZ = CFRandom(-.001,.001)-.01*MRGoreParts_Gravity+Vel.Z*.01;
			
			if(Water){Vel *= .5;AccelZ *= .5;}
			
			Float ReSize, Fade;
			ReSize = -(Size/Life);
			if(!LowAlpha){Fade = -1; ReSize *= .4;}
			
			if(!(Flags&SGPF_TEST))mo.A_SpawnParticleEx(ColTmp, Texman.CheckForTexture("glpart"), Fuzzy, Glow, Life+5, Size*CFRandom(.9, 1.1), 0, Offset.X+CFRandom(-.5,.5)*Scale,Offset.Y+CFRandom(-.5,.5)*Scale,Offset.Z+CFRandom(-.5,.5)*Scale,
				Vel.X,Vel.Y,Vel.Z, CFRandom(-.001,.001),CFRandom(-.001,.001),AccelZ, Alph, Fade, ReSize);

			Life -= (StartLife/(CircleLength/(Size*.75/Amount))*CFRandom(0, .8))/MRGoreParts_Speed;
			
			Particles++;
		}
		
		Return Particles;
	}
	
	Override int GetID(){Return 5;}
}

Class MRGP_Effect_CurveLineTorn: MRGP_Effect
{
	Override int DoParticleEffect(Actor mo, int Flags, Double Angle, Double Pitch, Color Col, double Amount, Double Scale, Double Alpha, Vector3 Offset, Double LifeM, Vector3 Force, Double MoVel)
	{
		if(!mo||!Players[ConsolePlayer].Camera)Return 0;
		
		if(!MRGoreParts_Draw)Return 0;
		if(!(Flags&SGPF_FixAmount))Amount *= MRGoreParts_Amount;
		if(Amount<=0)Return 0;
		Amount = Min(1.1, Amount);
		Float Dist = MRGP_DistanceMult;
		
		int Particles;
		
		Bool Water = mo.WaterLevel>2;
		if(Water)Amount *= .5;
		
		if(Flags&SGPF_NODIST)Dist = 1;
		else
		{
			Dist *= Max(1, 1+(MRGParts.MRDistance3D(mo, Players[ConsolePlayer].Camera)-80)*.0015*MRGoreParts_Distance);
			if(Scale>1)Dist/=Scale;
		}
		
		int Glow = 0;
		if(MRGoreParts_FullBright)Glow = SPF_FULLBRIGHT;
		int Fuzzy = STYLE_NONE;
		if(Flags&SGPF_Fuzzy)Fuzzy = STYLE_Shadow;
		
		Pitch -= CFRandom(5, 10);
		//Angle += CRandom(-15, 15);
		Double Forw = .4;//CFRandom(.01, .2);
		Double Size = CFRandom(3.4, 3.7)*MRGoreParts_Size*Dist;
		Float Life = CFRandom(30, 34)/MRGoreParts_Speed*LifeM;
		if(Water)Life *= 2;
		Double StartLife = Life;
		
		Double Roll = CRandom(175, 360);
		
		Double CircleLength = Random(120, 360*Min(1, MRGoreParts_Amount));
		Float Step = Max(.1, Size*.75*Max(1, Dist*.1)/Amount);
		
		Let Alph = MRGoreParts_Alpha;
		Let LowAlpha = MRGoreParts_LowAlpha;
		
		int Skip = -CRandom(6, 10);
		
		For(Double j=-CircleLength/2;j<CircleLength/2;j+=Step)
		{
			if(Skip>0){Skip--;Continue;}
			
			if(Skip<0)Skip++;
			else Skip=CRandom(-3, 6);
			
			Double Ang = (j+CFRandom(-1.5, 1.5))*Cos(Roll);
			Ang = Angle + Ang;
			Double Pit = (j+CFRandom(-1.5, 1.5))*Sin(Roll);
			Pit = Pitch + Pit;
			
			Vector3 Vel = (Actor.AngleToVector(Ang, Forw)*Cos(Abs(Pit)), (-Sin(Pit)*(1.-abs(j/(CircleLength/2))))*Forw);
			
			Float Bright = Max(MRGoreParts_Brightness*.5, Min(MRGoreParts_Brightness*1.5, MRGoreParts_Brightness+.1+Vel.Z*2));
			Bright += CFRandom(-.05, .05);
			Color ColTmp = Color(int(Col.R*Bright), int(Col.G*Bright), int(Col.B*Bright));
			
			Vel += Force;
			Vel *= MRGoreParts_Speed;
			Vel *= Scale;
			Vel *= Dist;
			Vel += mo.Vel*moVel;
			
			Double AccelZ = CFRandom(-.001,.001)-.01*MRGoreParts_Gravity+Vel.Z*.01;
			
			if(Water){Vel *= .5;AccelZ *= .5;}
			
			Float ReSize, Fade;
			ReSize = -(Size/Life);
			if(!LowAlpha){Fade = -1; ReSize *= .4;}
			
			if(!(Flags&SGPF_TEST))mo.A_SpawnParticleEx(ColTmp, Texman.CheckForTexture("glpart"), Fuzzy, Glow, Life+5, Size*CFRandom(.9, 1.1), 0, Offset.X+CFRandom(-.5,.5)*Scale,Offset.Y+CFRandom(-.5,.5)*Scale,Offset.Z+CFRandom(-.5,.5)*Scale,
				Vel.X,Vel.Y,Vel.Z, CFRandom(-.001,.001),CFRandom(-.001,.001),AccelZ, Alph, Fade, ReSize);

			Life -= (StartLife/(CircleLength/(Size*.75/Amount))*CFRandom(0, .8))/MRGoreParts_Speed;
			
			Particles++;
		}
		
		Return Particles;
	}
	
	Override int GetID(){Return 6;}
}

Class MRGP_Effect_Sparks: MRGP_Effect
{
	Override int DoParticleEffect(Actor mo, int Flags, Double Angle, Double Pitch, Color Col, double Amount, Double Scale, Double Alpha, Vector3 Offset, Double LifeM, Vector3 Force, Double MoVel)
	{
		if(!mo||!Players[ConsolePlayer].Camera)Return 0;
		
		if(!MRGoreParts_Draw)Return 0;
		
		if(mo.Waterlevel>2)
		{
			int Rand = CRandom(170, 200);
			MRGP_Effect.SpawnEffect('MRGP_Effect_Mist', mo, Flags, Angle, Pitch, Color(Rand,Rand,Rand), Amount, Scale, Alpha, Offset, LifeM, Force, MoVel);
			Return 0;
		}
		
		if(!(Flags&SGPF_FixAmount))Amount *= MRGoreParts_Amount;
		if(Amount<=0)Return 0;
		
		int Particles;
		
		Float Dist = MRGP_DistanceMult;
		
		if(Flags&SGPF_NODIST)Dist = 1;
		else
		{
			Dist *= Max(1, 1+(MRGParts.MRDistance3D(mo, Players[ConsolePlayer].Camera)-80)*.0015*MRGoreParts_Distance);
			if(Scale>1)Dist/=Scale;
		}
		
		Float Mult = Max(1, (CRandom(1, 3))/Max(1, Dist*.1)*Amount);
		
		For(float i1=0;i1<Mult;i1++)
		{
			Double Ang = CRandom(0, 360);
			Double Leng = CFRandom(0, .3);
			Vector3 Strn = (CFRandom(.5, 2), Cos(Ang)*Leng, Sin(Ang)*Leng);
			Vector3 Vel = (Actor.AngleToVector(Angle, Strn.X)*Cos(Abs(Pitch)), Abs(Cos(Pitch))*Strn.Z + -Sin(Pitch)*Strn.X);
			Vel.XY += Actor.AngleToVector(Angle+90, Strn.Y);
			Vel.XY += Actor.AngleToVector(Angle, Strn.Z)*Sin(Pitch);
			
			Vel += Force;
			Vel *= MRGoreParts_Speed;
			Vel *= Dist;
			Vel *= Scale;
			Vel += mo.Vel*moVel;
			
			Float Life = CFRandom(25, 35)/MRGoreParts_Speed*LifeM;//Min(25, 10/Strn.Length())/MRGoreParts_Speed*LifeM;
			Double Size = CFRandom(.7, .8)*Dist*MRGoreParts_Size*Scale;
			Vector3 Accel = -Vel*CFRandom(.004, .01);
			Accel.Z -= MRGoreParts_Gravity;
			
			Color ColTmp = Color(255,CRandom(180, 255),CRandom(0, 80));
			Vector3 Ofst = Vel;
			Ofst *= Mult/(i1+1);
			
			if(!(Flags&SGPF_TEST))mo.A_SpawnParticle(ColTmp, SPF_FULLBRIGHT, Life, Size, 0, Ofst.X*CFRandom(.3, .7)+Offset.X,Ofst.Y*CFRandom(.3, .7)+Offset.Y,5+Ofst.Z*CFRandom(.3, .7)+Offset.Z,
				Vel.X, Vel.Y, Vel.Z, Accel.X, Accel.Y, Accel.Z, 1, 0, -(Size/Life));
			
			Particles++;
		}
		
		Return Particles;
	}
}