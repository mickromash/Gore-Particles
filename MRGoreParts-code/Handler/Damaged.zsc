/*
	Spawning effects on impact, spawning wounds etc
*/

Extend Class MRGP_Handler
{
	Array<Actor> Wounded;
	Array<MRGP_Wound> Wounds;
	
	
	Void SpawnNoBlood(Actor mo, Actor inflictor=Null, Double Angle=0, Actor Source = Null, Bool HDestArmor = false, Vector3 Offset=(0,0,0))//Spec. effects for non bleeding actors
	{
		if(MRGoreParts_NoBloodMist)
		{
			if(!mo)Return;
			
			Actor Who = mo;
			Double ZOfst = mo.Height*.5;
			if(Inflictor&&MRGParts.Distance2D(Inflictor, mo)<mo.Radius*1.5){Who = Inflictor; Angle = Who.AngleTo(mo)+180; ZOfst = 0;}
			
			if(!Who)Return;
			
			Float Bright = CFRandom(.7, 1.4);
			
			Color Col = MRGoreParts_NoBloodMistColor;

			Col = Color(int(Col.R*Bright), int(Col.G*Bright), int(Col.B*Bright));
			
			Double PitchTo = mo.Pos.Z+mo.Height*.5;
			if(PitchTo==0)PitchTo += .1;
			MRGP_Effect.SpawnEffect('MRGP_Effect_Mist', Who, 0, Angle, Who.Pos.Z/PitchTo*90, Col, Offset:Offset+(0,0,ZOfst));
			if(MRGoreParts_NoBloodSndVol>0)MRGParts.StartSound(Who, NoBloodSound, CHAN_AUTO, Volume:MRGoreParts_NoBloodSndVol*MRGoreParts_SndVol);
		}
		if(HDestArmor)
		{
			Actor Who = mo;
			Double ZOfst = mo.Height*.5;
			if(Inflictor&& MRGParts.Distance2D(Inflictor, mo)<mo.Radius*1.5){Who = Inflictor; Angle = Who.AngleTo(mo)+180; ZOfst = 0;}
			
			if(!Who)Return;
			
			Double Pitch = 0;
			if(Source && PlayerPawn(Source) && Inflictor)Pitch = Inflictor.PitchTo(Source, 5, Source.Player.ViewZ-Source.Pos.Z);
			Pitch = 0;
			
			MRGP_Effect.SpawnEffect('MRGP_Effect_Sparks', Who, 0, Angle, Who.Pos.Z/(mo.Pos.Z+mo.Height*.5)*-90, Offset:Offset+(0,0,ZOfst));
		}
	}
	
	Void SpawnWound(Actor Thing=Null, Actor Inflictor=Null, Actor DamageSource=Null, Color Col=Color(0,0,0))
	{
		MRGP_Wound Token;//Wound thinker we're working with
		if(Wounded.Find(Thing)==Wounded.Size())//In case actor hasn't been wounded before, create a new wound thinker
		{
			MRGP_Wound a = New('MRGP_Wound');
			a.Owner = Thing;
			a.PostBeginPlay();
			Token = a;
		}
		else//Otherwise, work with wound thinker linked to this actor
		{
			if(Wounded.Find(Thing)>=Wounds.Size())Return;
			Token = Wounds[Wounded.Find(Thing)];
		}
		
		if(!Token){if(MRGoreParts_Debug)Console.Printf("Couldn't find or create a wound for "..Thing.GetClassName().." at "..Thing.Pos);Return;}
		
		Token.Col = Col;
		
		if(Inflictor != Thing && Inflictor != DamageSource)//Check if it wasn't SH (like bleeding in HDest)
		{
			Bool Replace = true;//Check wounds limit
			For(int i=0;i<MRGoreParts_MaxWounds;i++)
			{
				if(Token.Ages[i]<1)
				{
					//if(MRGoreParts_Debug)Console.Printf("\cdTarget pos:\cc "..Thing.Pos.XY.."\cg inflict pos:\cc "..Inflictor.Pos.XY);
					Vector3 Dif = LevelLocals.Vec3Diff(Inflictor.Pos, Thing.Pos);
	
					Vector3 Home = (0, 0, 0);
					
					Home.Y -= Dif.X*Cos(Thing.Angle-90) + Dif.Y*Sin(Thing.Angle-90);
					Home.X -= Dif.X*Cos(Thing.Angle) + Dif.Y*Sin(Thing.Angle);
					
					Home.XY *= .75;
					
					Home.X *= abs(Cos(Actor.DeltaAngle(Thing.Angle, Thing.AngleTo(Inflictor))));
					Home.Y *= abs(Sin(Actor.DeltaAngle(Thing.Angle, Thing.AngleTo(Inflictor))));

					Home.Z = -Dif.Z+5;
					Home.Z = Min(1, Home.Z/Thing.Height);
					
					if(Home.X>0)Home.X = Min(Home.X, Thing.Radius);
					else Home.X = Max(Home.X, -Thing.Radius);
					
					if(Home.Y>0)Home.Y = Min(Home.Y, Thing.Radius);
					else Home.Y = Max(Home.Y, -Thing.Radius);
					
					Token.Locs[i]=Home;
					Token.Angles[i]=Thing.AngleTo(Inflictor);
					Token.Ages[i]=35*15;
					Replace = false;
					Break;
				}
			}
			if(Replace)//Replace the oldest wound on actor
			{
				//if(MRGoreParts_Debug)Console.Printf("Targ "..Thing.Pos.XY.." inf "..Inflictor.Pos.XY);
				Vector3 Dif = LevelLocals.Vec3Diff(Inflictor.Pos, Thing.Pos);

				Vector3 Home = (0, 0, 0);
				
				Home.Y -= Dif.X*Cos(Thing.Angle-90) + Dif.Y*Sin(Thing.Angle-90);
				Home.X -= Dif.X*Cos(Thing.Angle) + Dif.Y*Sin(Thing.Angle);
				
				Home.XY *= .75;
				
				Home.X *= abs(Cos(Actor.DeltaAngle(Thing.Angle, Thing.AngleTo(Inflictor))));
				Home.Y *= abs(Sin(Actor.DeltaAngle(Thing.Angle, Thing.AngleTo(Inflictor))));

				Home.Z = -Dif.Z+5;
				Home.Z = Min(1, Home.Z/Thing.Height);
				
				if(Home.X>0)Home.X = Min(Home.X, Thing.Radius);
				else Home.X = Max(Home.X, -Thing.Radius);
				
				if(Home.Y>0)Home.Y = Min(Home.Y, Thing.Radius);
				else Home.Y = Max(Home.Y, -Thing.Radius);
				
				Token.Locs[0]=Home;
				Token.Angles[0]=Thing.AngleTo(Inflictor);
				Token.Ages[0]=35*15;
			}
		}
		else//Hideous bleeding
		{
			Array<int> Ages;
			For(int i=0;i<MRGoreParts_MaxWounds;i++)
			{
				if(Token.Ages[i]>0)
				{
					Ages.Push(i);
				}
			}
			
			if(Ages.Size()>0)Token.Ages[Ages[CRandom(0, Ages.Size()-1)]]=1;
			
			else
			{
				Token.Ages[0]=35*15;
				Token.Locs[0]=(Actor.AngleToVector(CRandom(0, 360), Thing.Radius*.3), CFRandom(.15, 1));
			}
		}
	}
	
	Void SpawnBloodDrop(Actor mo, Color Col)//Mainly for hdest
	{
		if(!MRGoreParts_Draw)Return;
		
		Float TempGrav = .3;
		
		For(int i=CRandom(0, 3);i<5;i++)
			mo.A_SpawnParticle(Col, 0, 20, CFRandom(3, 4), 0, CFRandom(-.5,.5),CFRandom(-.5,.5),.1*i, mo.Vel.X,mo.Vel.Y,0, 0,0,TempGrav);
		
		int Delay = 1;
		For(float i=mo.Pos.Z;i>mo.floorZ;i-=TempGrav)
		{
			TempGrav += abs(.3);
			Delay++;
		}
		
		Let a = MRGP_Spot.MRGSpawnSpot(Col, (mo.pos.x+CFRandom(-1, 1), mo.pos.y+CFRandom(-1, 1), mo.floorz+1), 150, Delay, 1, CFRandom(2, 4), CFRandom(.8, .9));
	}
	
	
	Void SpawnExitBlood(Actor mo, Actor Inflictor, Actor Source, int Damage, Color Col, int Flags)
	{
		if(!mo || !Inflictor || !Source || (Source == Inflictor))Return;
		
		if(CRandom(0, 10)<3)Return;
		
		if(Damaged.Find(mo) != Damaged.Size()){
			Return;
		}
		
		Double Pitch = 0;
		if(Source.Player)Pitch = Inflictor.PitchTo(Source, 5, Source.Player.ViewZ-Source.Pos.Z);
		else if(Source)Pitch = Inflictor.PitchTo(Source, 0, Source.Height*.9);
		
		Pitch = -Pitch;
		
		Let Spot = Inflictor;
		
		Vector3 OldPos = Spot.Pos;

		Spot.SetXYZ(Spot.Pos + (Actor.AngleToVector(Spot.AngleTo(Source)+180, mo.Radius), mo.Radius*Sin(Pitch)));//Hopefully it won't cause desync
		
		
		Double VOfst = 0;
		Double DifZ = Dif(Spot.Pos.Z, mo.pos.Z+mo.Height*.5);
		
		if(MRGParts.Distance2D(Inflictor, mo)>mo.Radius*1.5||DifZ>mo.Height*.5)Return;
		
		
		if(Effects.Size()>0)
			Effects[CRandom(0, Effects.Size()-1)].DoParticleEffect(Spot, Flags, Spot.AngleTo(Source)+180, -Pitch, Col, .5, offset:(0,0,VOfst));
		
		Spot.SetXYZ(OldPos);
		
		Damaged.Push(mo);
	}
	Array<Actor> Damaged;
	
	
	
	Override Void WorldThingDamaged(WorldEvent e)
	{
		if(!MRGoreParts_Draw)Return;
		
		if(!e.Thing.bIsMonster && !(e.Thing is 'PlayerPawn') && !e.Thing.bCorpse)Return;
		
		if((e.Thing.bNoBlood && !MRGoreParts_NoBloodMonsters) || (MRGoreParts_BlacklistOn && BlackList.Find(e.Thing.GetClass())!=BlackList.Size()))
		{
			SpawnNoBlood(e.Thing, e.Inflictor, e.DamageAngle);//Special effects for non bleeding actors
			Return;
		}
		
		if(MRGoreParts_BlacklistOn)
			For(int i=0;i<BlackList.Size();i++){
				if(e.Thing is BlackList[i]){SpawnNoBlood(e.Thing, e.Inflictor, e.DamageAngle);Return;}
			}
		
		/*if(MRGoreParts_Debug){
			String Damage = "";
			if(e.DamageFlags&DMG_EXPLOSION)Damage = Damage.."Explosion|";
			if(e.DamageFlags&DMG_USEANGLE)Damage = Damage.."Use_Angle|";
			if(e.DamageFlags&DMG_INFLICTOR_IS_PUFF)Damage = Damage.."IsPuff|";
			Console.Printf("Damage: "..e.DamageType.." Flags: "..Damage);
			if(e.DamageSource)Console.Printf("Source: "..e.DamageSource.GetClassName().." "..e.DamageSource.Pos);
			if(e.Inflictor && e.Inflictor!=e.DamageSource)Console.Printf("Inflictor: "..e.Inflictor.GetClassName().." "..e.Inflictor.Pos);
		}*/
		
		String HDest = 'HDOperator';
		if((Class<Actor>)(HDest))
		{
			String Armour = "HDArmourWorn";
			if(e.DamageType == 'bashing' && e.Thing.CountInv(Armour))
			{
				SpawnNoBlood(e.Thing, e.Inflictor, e.DamageAngle, e.DamageSource, true);
				Return;
			}
			if(e.DamageType != 'piercing' && e.DamageType != 'bleedout')Return;
		}
		
		Float Amount = MRGoreParts_Amount;
			
		Color Col = e.Thing.BloodColor;
		if(MRGoreParts_UseCustomColor)
		{
			Col = MRGoreParts_Color;
		}
		else
		{
			if(e.Thing.BloodColor==0 && e.Thing.BloodTranslation==0)Col = GameInfo.defaultbloodcolor;
			if(BldCols.CheckKey(e.Thing.GetClassName()))Col = BldCols.Get(e.Thing.GetClassName());
		}
		
		int Flags;
		if(BldFlags.CheckKey(e.Thing.GetClassName()))Flags = BldFlags.Get(e.Thing.GetClassName());
		
		int Glow = 0;
		if(Flags&GPBCF_Glow||MRGoreParts_FullBright)Glow = SGPF_Glow;
		
		int Fuzzy = 0;
		if(MRGoreParts_FuzzyBlood && (e.Thing.GetRenderStyle() == STYLE_OptFuzzy||e.Thing.GetRenderStyle() == STYLE_Fuzzy))Fuzzy = SGPF_Fuzzy;
		
		
				
		
		if(e.DamageType == 'bleedout')
		{
			Vector3 Pos = (Actor.AngleToVector(e.Thing.Angle + CFRandom(-90, 90), e.Thing.Radius*.7), CRandom(e.Thing.Height*.25, e.Thing.Height*.7));
			
			For(int i=CRandom(0, 2);i<4;i++)
				e.Thing.A_SpawnParticle(Col, Glow?SPF_FULLBRIGHT:0, 20, CFRandom(2, 3), 0, Pos.X,Pos.Y,Pos.Z+.1*i,
					0,0,0, 0,0,-.3);
			MRGP_Effect.SpawnEffect('MRGP_Effect_SimpleSplash', e.Thing, Glow, e.DamageAngle, 0, Col, 1, .6, 1, Pos);
		}
		
		if(!e.Inflictor)Return;

		//Console.Printf("\cdHealth: \c-"..e.Thing.Health.." \cgDamage: \c-"..e.Damage);
		//Console.Printf("Damage: "..e.DamageType.." Flags: "..Damage);
		
		if(MRGoreParts_Wounds && !PlayerPawn(e.Thing) && (Wounded.Find(e.Thing)!=Wounded.Size() || Wounded.Size()<MRGoreParts_MaxWounded) && e.DamageType != 'bleedout' && CRandom(0, 10)>4)
		{
			SpawnWound(e.Thing, e.Inflictor, e.DamageSource, Col);
		}
		
		if(e.Inflictor == e.Thing)Return;
		
		if(!e.DamageSource)Return;
		
		//Spawn effects
		Double Pitch = 0;
		if(e.DamageSource && e.DamageSource.Player)Pitch = e.Inflictor.PitchTo(e.DamageSource, 5, e.DamageSource.Player.ViewZ-e.DamageSource.Pos.Z);
		else if(e.DamageSource)Pitch = e.Inflictor.PitchTo(e.DamageSource, 0, e.DamageSource.Height*.9);
		
		Let Spot = e.Inflictor;
		Double VOfst = 0;
		Double DifZ = Dif(Spot.Pos.Z, e.Thing.pos.Z+e.Thing.Height*.5);

		if(MRGParts.Distance2D(e.Inflictor, e.Thing)>e.Thing.Radius*1.5||DifZ>e.Thing.Height*.5){Spot = e.Thing;VOfst = e.Thing.Height*.5;}
		
		
		if(Effects.Size()>0)
			Effects[CRandom(0, Effects.Size()-1)].DoParticleEffect(Spot, Fuzzy|Glow|SGPF_Spots, Spot.AngleTo(e.DamageSource), Pitch, Col, offset:(0,0,VOfst));
		For(int i=0;i<AlwaysEffects.Size();i++)
		{
			AlwaysEffects[i].DoParticleEffect(Spot, Fuzzy|Glow|SGPF_Spots, Spot.AngleTo(e.DamageSource), Pitch, Col, Offset:(0,0,VOfst));
		}
		
		if(CRandom(0, 50)>40)MRGParts.StartSound(e.Inflictor, DripSound, CHAN_AUTO, Volume:MRGoreParts_SndVol*MRGoreParts_DripSndVol);
		MRGParts.StartSound(e.Inflictor, HitSound, CHAN_AUTO, Volume:MRGoreParts_HitSndVol*MRGoreParts_SndVol);


		if(MRGoreParts_DrawFlyingBlood && CFRandom(0, 1)<MRGoreParts_FlyingBloodChance)
		{
			Float Strn = CRandom(4, 6);
			Float Pitch = -CRandom(0, 60);
			Vector3 Vel = (Actor.AngleToVector(e.Inflictor.AngleTo(e.DamageSource)+CRandom(-50, 50), Strn)*Cos(Pitch), -Sin(Pitch)*Strn);
			MRGP_FlyingBlood.Create(e.Inflictor.Pos, Col, Fuzzy|Glow, Scale:4*CFRandom(1, 2), Vel:Vel);
			MRGParts.StartSoundAt(e.Inflictor.Pos, SpraySound, CHAN_AUTO, Volume: CFRandom(.2, .3)*MRGoreParts_SndVol*MRGoreParts_SpraySndVol, Pitch: CFrandom(1.1, 1.2));
		}
		//Dripping blood
		if(MRGPartsCheckDraw(e.Inflictor) && MRGoreParts_DripOnImpact){
			Bool Drop = false;
			Vector3 Home = LevelLocals.Vec3Diff(e.Thing.Pos, e.Inflictor.Pos);

			Home.X *= Abs(Cos(Actor.DeltaAngle(e.Thing.Angle, e.Thing.AngleTo(e.Inflictor))));
			Home.Y *= Abs(Sin(Actor.DeltaAngle(e.Thing.Angle, e.Thing.AngleTo(e.Inflictor))));
			Home.Z += 5;
			Home.XY *= CFRandom(.5, 1);
			Home.XY += (CFRandom(-1, 1), CFRandom(-1, 1));
						
			For(int i=CRandom(0, 3)*Amount;i<6*Amount;i++){
				Float Dist = 1;
				if(e.DamageSource)Dist *= 1+(MRGParts.Distance3D(e.Inflictor, e.DamageSource)-80)*.0025;
				Float Size = CFRandom(.8, 1.6)*Dist;

				Float Bright = MRGoreParts_Brightness*CFrandom(.5, .9);
				Color ColTmp = Color(int(Col.R*Bright), int(Col.G*Bright), int(Col.B*Bright));
				if(!Drop){//Spot
					Let a = MRGP_Droplet.SpawnDrop(ColTmp, e.Thing.Pos + Home, Glow, RenderStyle:Fuzzy?STYLE_Shadow:STYLE_NORMAL);
					Drop = true;
				}
				e.Thing.A_SpawnParticleEx(ColTmp, Texman.CheckForTexture("glpart"), Fuzzy?STYLE_Shadow:STYLE_NORMAL, Glow, CRandom(29, 40), Size*1.3, 0, Home.X,Home.Y,Home.Z,
						0,0,CFRandom(0, 1), 0,0,-.2, 1, 0, -Size/40);
			}
		}
		
		if(MRGoreParts_ExitWound)SpawnExitBlood(e.Thing, e.Inflictor, e.DamageSource, e.Damage, Col, Fuzzy|Glow|SGPF_Spots);
	}
}